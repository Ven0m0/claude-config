#!/usr/bin/env node
import fs from "node:fs";

import { parseArgs, printTable, listAllDaemons, readJsonFileIfExists, writeJson, ensureDir } from "../lib/util.mjs";
import { loadMcpConfigs, resolveServer, summarizeServerForDisplay, listAllServers, readClaudeDesktopConfig, getUserConfigPath, getProjectConfigPath } from "../lib/config.mjs";
import { McpClient } from "../lib/mcp_client.mjs";
import { getToolsCached, compactToolSummaries } from "../lib/tool_index.mjs";
import { searchTools } from "../lib/search.mjs";
import { hydrateTools } from "../lib/hydrate.mjs";
import { createToolApi, executeWorkflow, writeRunArtifact } from "../lib/run.mjs";
import { isDaemonRunning, callViaDaemon, getDaemonStatus, shutdownDaemon, startDaemon, ensureDaemonRunning, warmServers, getCurrentDaemonPaths } from "../lib/daemon_client.mjs";
import { setServerAutoWarm, getServerState } from "../lib/state.mjs";

function usage() {
  return `
MCP Mode (cm) - Progressive MCP workflows for Claude Code

Usage:
  cm servers [--json]
  cm doctor  --server <name> [--no-connect] [--json]
  cm index   --server <name> [--refresh] [--json]
  cm search  "<query>" --server <name> [--limit 8] [--refresh] [--json]
  cm hydrate <tool1> <tool2> ... --server <name> [--out <dir>] [--refresh] [--json]
  cm run     --workflow <file.js> --tools <a,b,...> --server <name> [--retries 3] [--timeout-ms 300000]
  cm call    <tool> --server <name> [--args '{...}'] [--args-file path.json] [--json] [--no-daemon]

Daemon (persistent connections for faster calls):
  cm daemon start               → Start background daemon for current project
  cm daemon stop                → Stop current project's daemon
  cm daemon status [--json]     → Show current project's daemon status
  cm daemon status --all        → List all running daemons
  cm daemon list                → Alias for status --all
  cm daemon warm [<server>]     → Pre-warm server(s)

Configuration:
  cm config <server> autoWarm true|false  → Enable/disable auto-warm for server

Import from Claude Desktop (macOS):
  cm import --from desktop [--dry-run]           → Import all servers from Claude Desktop
  cm import --from desktop server1 server2       → Import specific servers
  cm import --from desktop --scope project       → Import to project config instead of user

Progressive Disclosure Flow:
  1. cm servers              → Discover available MCP servers
  2. cm index --server X     → List tools on server X
  3. cm search "..." --server X → Find relevant tools
  4. cm hydrate tool1 --server X → Get full schemas
  5. cm run --server X ...   → Execute workflow

Manual connection overrides (optional):
  --http-url <url> [--headers-json '{"Authorization":"Bearer ..."}']
  --stdio-command <cmd> [--stdio-args "a,b,c"] [--env-json '{"KEY":"VALUE"}']

Notes:
- MCP Mode uses SEPARATE config files (~/.claude/mcp.json) from Claude Code's
  native configs (~/.claude.json, .mcp.json) to avoid context injection.
- Tool inventory is cached under .claude/mcp-mode/cache/<server>/tools.json
- When daemon is running, 'cm call' uses it automatically (~5x faster).
`.trim();
}

function fail(msg, code = 1) {
  process.stderr.write(String(msg).trim() + "\n");
  process.exit(code);
}

/**
 * Resolve server entry from explicit flags OR from mcp.json.
 * @param {Record<string, any>} flags
 */
function resolveServerFromFlags(flags) {
  // HTTP override
  if (flags["http-url"]) {
    const url = String(flags["http-url"]);
    let headers = {};
    if (flags["headers-json"]) {
      try {
        headers = JSON.parse(String(flags["headers-json"]));
      } catch (err) {
        throw new Error(`Invalid --headers-json: ${err.message || err}`);
      }
    }
    return { serverName: flags.server ? String(flags.server) : "http", entry: { type: "http", url, headers } };
  }

  // stdio override
  if (flags["stdio-command"]) {
    const command = String(flags["stdio-command"]);
    const args = flags["stdio-args"]
      ? String(flags["stdio-args"])
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean)
      : [];
    let env = {};
    if (flags["env-json"]) {
      try {
        env = JSON.parse(String(flags["env-json"]));
      } catch (err) {
        throw new Error(`Invalid --env-json: ${err.message || err}`);
      }
    }
    return { serverName: flags.server ? String(flags.server) : "stdio", entry: { type: "stdio", command, args, env } };
  }

  // Default: mcp.json
  const resolved = resolveServer({ server: flags.server });
  return { serverName: resolved.serverName, entry: resolved.entry };
}

async function withClient(serverName, entry, fn) {
  const client = new McpClient({ serverName, entry });
  try {
    return await fn(client);
  } finally {
    try {
      await client.close();
    } catch {}
  }
}

async function cmdServers(args) {
  const servers = listAllServers();

  if (args.flags.json) {
    process.stdout.write(JSON.stringify({ servers }, null, 2) + "\n");
    return;
  }

  if (!servers.length) {
    process.stdout.write("No MCP servers configured.\n");
    process.stdout.write("Add servers to ~/.claude/mcp.json or <project>/.claude/mcp.json\n");
    return;
  }

  printTable(
    servers.map((s) => ({
      name: s.name,
      type: s.type,
    })),
    ["name", "type"]
  );

  process.stdout.write(`\n${servers.length} MCP server(s) available to mcp-mode.\n`);
  process.stdout.write(`Tip: These servers are NOT in Claude Code's context - that's the point!\n`);
}

async function cmdDoctor(args) {
  const { projectPath, userPath } = loadMcpConfigs();

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const summary = summarizeServerForDisplay(entry);

  if (args.flags.json) {
    const out = {
      projectMcpPath: projectPath,
      userMcpPath: userPath,
      serverName,
      server: summary,
    };
    if (args.flags["no-connect"]) {
      process.stdout.write(JSON.stringify(out, null, 2) + "\n");
      return;
    }
    const res = await withClient(serverName, entry, async (client) => {
      await client.init();
      const tools = await client.listTools();
      return {
        toolCount: Array.isArray(tools?.tools) ? tools.tools.length : 0,
        protocolVersion: client.negotiatedProtocolVersion,
        serverInfo: client.serverInfo,
      };
    });
    out.connection = res;
    process.stdout.write(JSON.stringify(out, null, 2) + "\n");
    return;
  }

  process.stdout.write(`Project mcp.json: ${projectPath || "(not found)"}\n`);
  process.stdout.write(`User mcp.json:    ${userPath}\n`);
  process.stdout.write(`Server: ${serverName}\n`);
  process.stdout.write(`Config: ${JSON.stringify(summary, null, 2)}\n`);

  if (!args.flags["no-connect"]) {
    process.stdout.write(`\nConnecting...\n`);
    const res = await withClient(serverName, entry, async (client) => {
      await client.init();
      const list = await client.listTools();
      return {
        toolCount: Array.isArray(list?.tools) ? list.tools.length : 0,
        protocolVersion: client.negotiatedProtocolVersion,
        serverInfo: client.serverInfo,
      };
    });
    process.stdout.write(`Connected. Tools: ${res.toolCount}\n`);
    process.stdout.write(`Protocol: ${res.protocolVersion}\n`);
    if (res.serverInfo) process.stdout.write(`ServerInfo: ${JSON.stringify(res.serverInfo)}\n`);
  }
}

async function cmdIndex(args) {
  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools, cacheFile, cached } = await getToolsCached({ serverName, client, refresh });
    const summaries = compactToolSummaries(tools);
    return { summaries, cacheFile, cached };
  });

  if (args.flags.json) {
    process.stdout.write(
      JSON.stringify({ serverName, cacheFile: res.cacheFile, cached: res.cached, tools: res.summaries }, null, 2) + "\n"
    );
    return;
  }

  printTable(
    res.summaries.map((t) => ({ 
      name: t.name, 
      requires: t.requires || "-",
      description: t.description.slice(0, 80) 
    })),
    ["name", "requires", "description"]
  );
  process.stdout.write(`Cache: ${res.cacheFile} (${res.cached ? "hit" : "refreshed"})\n`);
}

async function cmdSearch(args) {
  const query = args._[1];
  if (!query) fail(`Missing query.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const limit = args.flags.limit ? Number(args.flags.limit) : 8;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools } = await getToolsCached({ serverName, client, refresh });
    const matches = searchTools(tools, query, { limit });
    return { matches };
  });

  if (args.flags.json) {
    process.stdout.write(JSON.stringify({ serverName, query, matches: res.matches }, null, 2) + "\n");
    return;
  }

  printTable(
    res.matches.map((m) => ({ name: m.name, score: m.score.toFixed(2), description: m.description.slice(0, 140) })),
    ["name", "score", "description"]
  );
}

async function cmdHydrate(args) {
  const toolNames = args._.slice(1);
  if (!toolNames.length) fail(`Missing tool names.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const outDir = args.flags.out ? String(args.flags.out) : undefined;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools } = await getToolsCached({ serverName, client, refresh });
    return hydrateTools({ serverName, tools, toolNames, outDir });

  });

  if (args.flags.json) {
    process.stdout.write(
      JSON.stringify({ serverName, outDir: res.outDir, selectedCount: res.selectedCount, toolmap: res.toolmap }, null, 2) +
        "\n"
    );
    return;
  }

  process.stdout.write(`Hydrated ${res.selectedCount} tools to:\n  ${res.outDir}\n`);
}

async function cmdRun(args) {
  const workflowPath = args.flags.workflow || args.flags.w;
  const toolsCsv = args.flags.tools || args.flags.t;
  if (!workflowPath || !toolsCsv) fail(`Missing --workflow and/or --tools.\n\n${usage()}`);

  const toolNames = String(toolsCsv)
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  if (!fs.existsSync(workflowPath)) fail(`Workflow file not found: ${workflowPath}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const timeoutMs = args.flags["timeout-ms"] ? Number(args.flags["timeout-ms"]) : undefined;
  const allowUnsafe = !!args.flags["allow-unsafe"];
  const maxRetries = args.flags.retries ? Number(args.flags.retries) : 3;

  const trace = [];

  const output = await withClient(serverName, entry, async (client) => {
    // Ensure tools exist (via cache)
    const { tools } = await getToolsCached({ serverName, client, refresh });
    const available = new Set((tools || []).map((t) => t?.name));
    const missing = toolNames.filter((n) => !available.has(n));
    if (missing.length) {
      throw new Error(`Unknown tool(s) for server "${serverName}": ${missing.join(", ")}`);
    }

    const toolApi = createToolApi({ client, toolNames, trace, maxRetries });
    const { result, logs } = await executeWorkflow({
      workflowPath,
      toolApi,
      timeoutMs,
      allowUnsafe,
    });
    return { result, logs, toolmap: toolApi.toolmap };
  }).catch((err) => {
    // Persist a failure run artifact too.
    const failOut = {
      ok: false,
      error: String(err?.message || err),
    };
    const artifact = writeRunArtifact({
      serverName,
      workflowPath,
      tools: toolNames,
      output: failOut,
      trace,
    });
    if (args.flags.json) {
      process.stdout.write(JSON.stringify({ ...failOut, artifact }, null, 2) + "\n");
      return;
    }
    fail(`${failOut.error}\nArtifact: ${artifact.file}`);
  });

  const okOut = { ok: true, result: output.result, logs: output.logs, toolmap: output.toolmap };
  const artifact = writeRunArtifact({
    serverName,
    workflowPath,
    tools: toolNames,
    output: okOut,
    trace,
  });

  process.stdout.write(JSON.stringify({ ...okOut, artifact }, null, 2) + "\n");
}

async function cmdCall(args) {
  const tool = args._[1];
  if (!tool) fail(`Missing tool name.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  let argObj = {};
  if (args.flags["args"]) {
    try {
      argObj = JSON.parse(String(args.flags["args"]));
    } catch (err) {
      fail(`Invalid --args JSON: ${err.message || err}`);
    }
  } else if (args.flags["args-file"]) {
    const p = String(args.flags["args-file"]);
    try {
      argObj = JSON.parse(fs.readFileSync(p, "utf-8"));
    } catch (err) {
      fail(`Invalid --args-file: ${err.message || err}`);
    }
  }

  // Try daemon first (unless --no-daemon flag is set)
  // Auto-start daemon if not running
  if (!args.flags["no-daemon"]) {
    const daemonReady = await ensureDaemonRunning();
    if (daemonReady) {
      const res = await callViaDaemon({ server: serverName, tool, args: argObj });
      if (!res.ok) {
        fail(`Daemon call failed: ${res.error}`);
      }
      if (args.flags.json) {
        process.stdout.write(JSON.stringify(res, null, 2) + "\n");
        return;
      }
      process.stdout.write(JSON.stringify(res.result, null, 2) + "\n");
      return;
    }
  }

  // Direct call (no daemon)
  const out = await withClient(serverName, entry, async (client) => {
    const res = await client.callTool({ name: tool, arguments: argObj, timeoutMs: 60_000 });
    return res;
  });

  if (args.flags.json) {
    process.stdout.write(JSON.stringify(out, null, 2) + "\n");
    return;
  }
  process.stdout.write(JSON.stringify(out.structured ?? out.text ?? out.raw, null, 2) + "\n");
}

async function cmdDaemon(args) {
  const subcmd = args._[1];
  const { socket, projectRoot } = getCurrentDaemonPaths();

  if (subcmd === "start") {
    const running = await isDaemonRunning();
    if (running) {
      process.stdout.write("Daemon is already running.\n");
      if (projectRoot) {
        process.stdout.write(`Project: ${projectRoot}\n`);
      }
      return;
    }
    try {
      const result = await startDaemon();
      process.stdout.write(`Daemon started (PID: ${result.pid})\n`);
      process.stdout.write(`Socket: ${result.socketPath}\n`);
      if (result.projectRoot) {
        process.stdout.write(`Project: ${result.projectRoot}\n`);
      } else {
        process.stdout.write(`Project: (global)\n`);
      }
    } catch (err) {
      fail(`Failed to start daemon: ${err.message}`);
    }
    return;
  }

  if (subcmd === "stop") {
    const running = await isDaemonRunning();
    if (!running) {
      process.stdout.write("Daemon is not running.\n");
      return;
    }
    await shutdownDaemon();
    process.stdout.write("Daemon stopped.\n");
    if (projectRoot) {
      process.stdout.write(`Project: ${projectRoot}\n`);
    }
    return;
  }

  if (subcmd === "status" || subcmd === "list") {
    // --all flag shows all daemons across all projects
    if (args.flags.all || subcmd === "list") {
      const allDaemons = listAllDaemons();
      
      if (args.flags.json) {
        process.stdout.write(JSON.stringify({ daemons: allDaemons }, null, 2) + "\n");
        return;
      }
      
      if (!allDaemons.length) {
        process.stdout.write("No daemons found.\n");
        return;
      }
      
      printTable(
        allDaemons.map((d) => ({
          project: d.projectPath || "(global)",
          pid: d.pid,
          status: d.alive ? "running" : (d.stale ? "stale" : "unknown"),
          started: d.startedAt?.split("T")[0] || "-",
        })),
        ["project", "pid", "status", "started"]
      );
      process.stdout.write(`\n${allDaemons.length} daemon(s) found.\n`);
      return;
    }
    
    // Default: show current project's daemon
    const running = await isDaemonRunning();
    if (!running) {
      if (args.flags.json) {
        process.stdout.write(JSON.stringify({ running: false, socket, projectRoot }, null, 2) + "\n");
      } else {
        process.stdout.write("Daemon is not running.\n");
        process.stdout.write(`Socket: ${socket}\n`);
        if (projectRoot) {
          process.stdout.write(`Project: ${projectRoot}\n`);
        } else {
          process.stdout.write(`Project: (global)\n`);
        }
      }
      return;
    }

    const status = await getDaemonStatus();
    if (args.flags.json) {
      process.stdout.write(JSON.stringify({ running: true, socket, projectRoot, ...status }, null, 2) + "\n");
      return;
    }

    const uptimeMin = Math.floor((status.uptime || 0) / 60000);
    process.stdout.write(`Daemon running (uptime: ${uptimeMin}m)\n`);
    process.stdout.write(`Socket: ${socket}\n`);
    if (projectRoot) {
      process.stdout.write(`Project: ${projectRoot}\n`);
    } else {
      process.stdout.write(`Project: (global)\n`);
    }
    process.stdout.write("\n");

    if (status.connections?.length) {
      printTable(
        status.connections.map((c) => ({
          server: c.name,
          type: c.type,
          state: c.state,
          uptime: c.uptime || "-",
          calls: c.callCount,
        })),
        ["server", "type", "state", "uptime", "calls"]
      );
    } else {
      process.stdout.write("No server connections.\n");
    }
    return;
  }

  if (subcmd === "warm") {
    const running = await isDaemonRunning();
    if (!running) {
      // Auto-start daemon for warm command
      try {
        await startDaemon();
        process.stdout.write("Daemon started.\n");
      } catch (err) {
        fail(`Failed to start daemon: ${err.message}`);
      }
    }

    const serverName = args._[2]; // Optional: specific server
    const result = await warmServers(serverName);

    if (args.flags.json) {
      process.stdout.write(JSON.stringify(result, null, 2) + "\n");
      return;
    }

    if (serverName) {
      process.stdout.write(result.warmed ? `Warmed: ${serverName}\n` : `Already warm: ${serverName}\n`);
    } else {
      const { warmed = [], failed = [] } = result;
      if (warmed.length) {
        process.stdout.write(`Warmed ${warmed.length} server(s): ${warmed.join(", ")}\n`);
      }
      if (failed.length) {
        process.stdout.write(`Failed: ${failed.join(", ")}\n`);
      }
      if (!warmed.length && !failed.length) {
        process.stdout.write("All servers already warm or none configured for auto-warm.\n");
      }
    }
    return;
  }

  fail(`Unknown daemon subcommand: ${subcmd}\nUsage: cm daemon start|stop|status|warm`);
}

async function cmdConfig(args) {
  const serverName = args._[1];
  const key = args._[2];
  const value = args._[3];

  if (!serverName || !key) {
    fail("Usage: cm config <server> <key> <value>\n\nSupported keys:\n  autoWarm true|false  - Enable/disable auto-warm for server");
  }

  if (key === "autoWarm") {
    if (value !== "true" && value !== "false") {
      fail("autoWarm must be 'true' or 'false'");
    }
    setServerAutoWarm(serverName, value === "true");
    process.stdout.write(`Set ${serverName}.autoWarm = ${value}\n`);
    return;
  }

  fail(`Unknown config key: ${key}\nSupported: autoWarm`);
}

async function cmdImport(args) {
  const from = args.flags.from;
  if (!from) {
    fail("Missing --from flag.\n\nUsage: cm import --from desktop [server1 server2 ...] [--dry-run] [--scope user|project]");
  }
  if (from !== "desktop") {
    fail("Currently only --from desktop is supported.");
  }

  const serverNames = args._.slice(1); // Optional: specific servers
  const dryRun = !!args.flags["dry-run"];
  const scope = args.flags.scope || "user"; // user or project

  if (scope !== "user" && scope !== "project") {
    fail("--scope must be 'user' or 'project'");
  }

  // Read Claude Desktop config
  const desktopConfig = readClaudeDesktopConfig();
  if (!desktopConfig) {
    fail(
      "Claude Desktop config not found.\n" +
      "Expected: ~/Library/Application Support/Claude/claude_desktop_config.json\n" +
      "(This feature requires Claude Desktop to be installed on macOS)"
    );
  }

  const allServers = desktopConfig.mcpServers || {};
  if (!Object.keys(allServers).length) {
    fail("No MCP servers found in Claude Desktop config.");
  }

  // Filter servers if names specified
  let toImport;
  if (serverNames.length > 0) {
    toImport = {};
    const notFound = [];
    for (const name of serverNames) {
      if (allServers[name]) {
        toImport[name] = allServers[name];
      } else {
        notFound.push(name);
      }
    }
    if (notFound.length) {
      fail(
        `Server(s) not found in Claude Desktop config: ${notFound.join(", ")}\n` +
        `Available: ${Object.keys(allServers).join(", ")}`
      );
    }
  } else {
    toImport = allServers;
  }

  // Dry run: just display
  if (dryRun) {
    process.stdout.write("Servers that would be imported from Claude Desktop:\n\n");
    printTable(
      Object.entries(toImport).map(([name, config]) => ({
        name,
        type: config.command ? "stdio" : (config.url ? "http" : "unknown"),
        command: config.command || config.url || "-",
      })),
      ["name", "type", "command"]
    );
    process.stdout.write(`\n${Object.keys(toImport).length} server(s) would be imported.\n`);
    process.stdout.write("Run without --dry-run to import.\n");
    return;
  }

  // Get target path
  let targetPath;
  try {
    targetPath = scope === "project" ? getProjectConfigPath() : getUserConfigPath();
  } catch (err) {
    fail(err.message);
  }

  // Transform to MCP Mode format (add type field)
  const transformed = {};
  for (const [name, config] of Object.entries(toImport)) {
    if (config.command) {
      transformed[name] = {
        type: "stdio",
        command: config.command,
        args: config.args || [],
        env: config.env || {},
      };
    } else if (config.url) {
      transformed[name] = {
        type: "http",
        url: config.url,
        headers: config.headers || {},
      };
    } else {
      // Unknown format, copy as-is
      transformed[name] = { ...config };
    }
  }

  // Read existing config and merge
  const existing = readJsonFileIfExists(targetPath) || { mcpServers: {} };
  const merged = {
    ...existing,
    mcpServers: { ...existing.mcpServers, ...transformed },
  };

  // Ensure directory exists and write
  const dir = targetPath.substring(0, targetPath.lastIndexOf("/"));
  ensureDir(dir);
  writeJson(targetPath, merged);

  process.stdout.write(`Imported ${Object.keys(toImport).length} server(s) to ${targetPath}\n`);
  process.stdout.write(`Servers: ${Object.keys(toImport).join(", ")}\n`);
  process.stdout.write("\nRun 'cm servers' to verify.\n");
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const cmd = args._[0];

  if (!cmd || cmd === "help" || cmd === "--help" || cmd === "-h") {
    process.stdout.write(usage() + "\n");
    return;
  }

  try {
    if (cmd === "servers") return await cmdServers(args);
    if (cmd === "doctor") return await cmdDoctor(args);
    if (cmd === "index") return await cmdIndex(args);
    if (cmd === "search") return await cmdSearch(args);
    if (cmd === "hydrate") return await cmdHydrate(args);
    if (cmd === "run") return await cmdRun(args);
    if (cmd === "call") return await cmdCall(args);
    if (cmd === "daemon") return await cmdDaemon(args);
    if (cmd === "config") return await cmdConfig(args);
    if (cmd === "import") return await cmdImport(args);
    fail(`Unknown command: ${cmd}\n\n${usage()}`);
  } catch (err) {
    fail(err.message || err);
  }
}

main();
