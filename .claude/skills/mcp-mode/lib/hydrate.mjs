import path from "node:path";
import fs from "node:fs";
import { ensureDir, nowIsoCompact, safeIdentifier, uniqueSafeToolMap, writeJson, getMcpModeDataDir, serverNameToDirName } from "./util.mjs";

/** @param {string} s */
function toPascalCase(s) {
  if (!s) return "Tool";
  return s.charAt(0).toUpperCase() + s.slice(1);
}

/**
 * Best-effort JSON Schema â†’ TypeScript type string.
 * This is intentionally conservative: unknown/complex schemas become `any`.
 * @param {any} schema
 * @param {number} depth
 */
function schemaToTs(schema, depth = 0) {
  if (!schema || typeof schema !== "object") return "any";
  if (depth > 8) return "any";
  if (schema.$ref) return "any";

  // enum
  if (Array.isArray(schema.enum) && schema.enum.length) {
    const vals = schema.enum;
    if (vals.length > 20) return typeof vals[0] === "number" ? "number" : "string";
    return vals
      .map((v) => (typeof v === "string" ? JSON.stringify(v) : typeof v === "number" ? String(v) : "any"))
      .join(" | ");
  }

  // anyOf/oneOf/allOf
  for (const key of ["oneOf", "anyOf"]) {
    if (Array.isArray(schema[key]) && schema[key].length) {
      return schema[key].map((s) => schemaToTs(s, depth + 1)).join(" | ");
    }
  }
  if (Array.isArray(schema.allOf) && schema.allOf.length) {
    return schema.allOf.map((s) => schemaToTs(s, depth + 1)).join(" & ");
  }

  const t = schema.type;

  if (t === "string") return "string";
  if (t === "number" || t === "integer") return "number";
  if (t === "boolean") return "boolean";
  if (t === "null") return "null";

  if (t === "array") {
    const item = schema.items ? schemaToTs(schema.items, depth + 1) : "any";
    return `Array<${item}>`;
  }

  if (t === "object" || schema.properties || schema.additionalProperties) {
    const props = schema.properties || {};
    const req = new Set(Array.isArray(schema.required) ? schema.required : []);
    const lines = ["{"];

    for (const [k, v] of Object.entries(props)) {
      const optional = req.has(k) ? "" : "?";
      lines.push(`  ${JSON.stringify(k)}${optional}: ${schemaToTs(v, depth + 1)};`);
    }

    if (schema.additionalProperties) {
      if (schema.additionalProperties === true) {
        lines.push(`  [key: string]: any;`);
      } else if (typeof schema.additionalProperties === "object") {
        lines.push(`  [key: string]: ${schemaToTs(schema.additionalProperties, depth + 1)};`);
      }
    }

    lines.push("}");
    return lines.join("\n");
  }

  // If type omitted but properties exist
  if (schema.properties) return schemaToTs({ ...schema, type: "object" }, depth + 1);

  return "any";
}

/**
 * Generate a hydration bundle (schemas + TS types + safe tool map).
 * @param {{
 *   serverName: string,
 *   tools: any[],
 *   toolNames: string[],
 *   outDir?: string,
 * }} opts
 */
export function hydrateTools(opts) {
  const ts = nowIsoCompact();
  const serverDir = serverNameToDirName(opts.serverName);
  const baseOut =
    opts.outDir ||
    path.join(getMcpModeDataDir(), "hydrated", serverDir, ts);

  ensureDir(baseOut);

  // Select tools by name
  const byName = new Map(opts.tools.map((t) => [t?.name, t]));
  const selected = [];
  for (const n of opts.toolNames) {
    const t = byName.get(n);
    if (t) selected.push(t);
  }

  // Build collision-free toolmap using shared function
  const selectedNames = selected.map(t => t?.name || "tool");
  const toolmap = uniqueSafeToolMap(selectedNames);

  writeJson(path.join(baseOut, "tools.json"), selected);
  writeJson(path.join(baseOut, "toolmap.json"), toolmap);

  // Also provide an ESM-friendly toolmap module (avoids JSON import assertions).
  const toolmapModule = `// Auto-generated by mcp-mode.\nexport default ${JSON.stringify(toolmap, null, 2)};\n`;
  fs.writeFileSync(path.join(baseOut, "toolmap.mjs"), toolmapModule, "utf-8");

  // types.d.ts - use toolmap keys (already collision-free)
  const typeLines = [
    `// Auto-generated by mcp-mode (best-effort).`,
    `// This file exists to improve IDE autocomplete; it is NOT a contract.`,
    ``,
  ];

  // Build reverse map: toolName -> safeName for lookup
  const nameToSafe = Object.create(null);
  for (const [safe, name] of Object.entries(toolmap)) {
    nameToSafe[name] = safe;
  }

  for (const t of selected) {
    const toolName = t?.name || "tool";
    const safe = nameToSafe[toolName] || safeIdentifier(toolName);
    const pascal = toPascalCase(safe);
    const inSchema = t?.inputSchema || t?.parameters || null;
    const outSchema = t?.outputSchema || null;

    const argsTs = schemaToTs(inSchema, 0);
    const resTs = outSchema ? schemaToTs(outSchema, 0) : "any";

    typeLines.push(`export type ${pascal}Args = ${argsTs};`);
    typeLines.push(`export type ${pascal}Result = ${resTs};`);
    typeLines.push("");
  }

  fs.writeFileSync(path.join(baseOut, "types.d.ts"), typeLines.join("\n"), "utf-8");

  // api.mjs: convenience builder (requires you to provide callTool)
  const apiLines = [
    `// Auto-generated by mcp-mode.`,
    `// Usage:`,
    `//   import { buildApi } from "./api.mjs";`,
    `//   import toolmap from "./toolmap.mjs";`,
    `//   const api = buildApi((name, args) => client.callTool({ name, arguments: args }));`,
    `import toolmap from "./toolmap.mjs";`,
    ``,
    `export function buildApi(callTool) {`,
    `  if (typeof callTool !== "function") throw new Error("buildApi requires a callTool(name,args) function");`,
    `  const api = { call: callTool };`,
    `  for (const [safeName, toolName] of Object.entries(toolmap)) {`,
    `    api[safeName] = (args) => callTool(toolName, args || {});`,
    `  }`,
    `  return api;`,
    `}`,
    ``,
  ];
  fs.writeFileSync(path.join(baseOut, "api.mjs"), apiLines.join("\n"), "utf-8");

  return { outDir: baseOut, selectedCount: selected.length, toolmap };
}
