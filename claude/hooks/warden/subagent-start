#!/usr/bin/env bash
# subagent-start: Budget enforcement + tracking + guidance
set -euo pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

SUBAGENT_COUNT_FILE="$WARDEN_STATE_DIR/subagent-count"

_warden_read_input || exit 0

IFS=$'\t' read -r AGENT_ID AGENT_TYPE SESSION_ID < <(
    printf '%s' "$WARDEN_INPUT" | jq -r '[.agent_id // "unknown", .agent_type // "", .session_id // ""] | @tsv' 2>/dev/null
) || exit 0

AGENT_ID=$(_warden_sanitize_id "$AGENT_ID")
SESSION_ID=$(_warden_sanitize_id "$SESSION_ID")
[[ -z "$AGENT_ID" ]] && AGENT_ID="unknown"

mkdir -p "$WARDEN_SUBAGENT_STATE_DIR" "$WARDEN_STATE_DIR"
EPOCH=$(date +%s)

# === BUDGET ENFORCEMENT ===
if ! _warden_budget_check; then
  STATS=$(_warden_budget_export)
  UTIL=$(echo "$STATS" | jq -r '.utilization // 100')
  CONSUMED=$(echo "$STATS" | jq -r '.consumed // 0')
  TOTAL=$(echo "$STATS" | jq -r '.total_limit // 0')
  cat << EOF
{
  "continue": false,
  "stopReason": "Budget exhausted (${UTIL}% used). ${CONSUMED}/${TOTAL} tokens. Wait for subagents or increase WARDEN_BUDGET_TOTAL."
}
EOF
  exit 0
fi

# Check budget thresholds for alerts
ALERT_FILE="$WARDEN_STATE_DIR/budget-alert"
STATS=$(_warden_budget_export)
UTIL=$(echo "$STATS" | jq -r '.utilization // 0' | cut -d. -f1)

if [ "$UTIL" -ge 90 ]; then
  echo "CRITICAL|$UTIL|$(date +%s)" > "$ALERT_FILE"
  _warden_notify critical "Claude Budget Alert" "Budget at ${UTIL}%!" || true
elif [ "$UTIL" -ge 75 ]; then
  PREV_LEVEL=$(cat "$ALERT_FILE" 2>/dev/null | cut -d'|' -f1 || echo "")
  if [ "$PREV_LEVEL" != "WARNING" ] && [ "$PREV_LEVEL" != "CRITICAL" ]; then
    echo "WARNING|$UTIL|$(date +%s)" > "$ALERT_FILE"
    _warden_notify normal "Claude Budget Warning" "Budget at ${UTIL}%" || true
  fi
fi

# Store state for cleanup
echo "$EPOCH" > "$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID.start"
[[ -n "$SESSION_ID" ]] && echo "$AGENT_ID" > "$WARDEN_SUBAGENT_STATE_DIR/session-$SESSION_ID"
printf 'AGENT_TYPE=%s\nSESSION_ID=%s\n' "$AGENT_TYPE" "$SESSION_ID" > "$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID"

# Log subagent start to unified stats
AGENT_STATS="$HOME/.claude/agent-stats.csv"
if [ ! -f "$AGENT_STATS" ]; then
  echo "timestamp,agent_id,agent_category,agent_type,duration_seconds,session_id,status" > "$AGENT_STATS"
fi
echo "$(_warden_date_iso),$AGENT_ID,subagent,$AGENT_TYPE,0,$SESSION_ID,started" >> "$AGENT_STATS"

# Emit subagent_start event to events.jsonl for Loki/Grafana
_TS=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
_AT_SAFE="${AGENT_TYPE//\"/\\\"}"
printf '{"timestamp":%d,"event_type":"subagent_start","tool":"SubagentStart","session_id":"%s","agent_id":"%s","agent_type":"%s"}\n' \
  "$_TS" "$SESSION_ID" "$AGENT_ID" "$_AT_SAFE" \
  >> "$WARDEN_EVENTS_FILE" 2>/dev/null

# Track active subagent count per session (with cross-platform locking)
if [ -n "$SESSION_ID" ]; then
  _increment_count() {
    PREV_COUNT=0
    if [ -f "$SUBAGENT_COUNT_FILE" ]; then
      IFS='|' read -r PREV_SESSION PREV_COUNT _PREV_TS < "$SUBAGENT_COUNT_FILE"
      [ "$PREV_SESSION" != "$SESSION_ID" ] && PREV_COUNT=0
    fi
    [[ "$PREV_COUNT" =~ ^[0-9]+$ ]] || PREV_COUNT=0
    printf '%s|%s|%s\n' "$SESSION_ID" "$((PREV_COUNT + 1))" "$EPOCH" > "$SUBAGENT_COUNT_FILE"
  }
  _warden_with_lock "$WARDEN_STATE_DIR/subagent-count.lock.d" _increment_count
fi
_warden_write_budget_prom

# Inject type-specific guidance for all agent types
GUIDANCE=""
case "$AGENT_TYPE" in
  Explore)
    GUIDANCE="Pattern: tree -> Glob -> Grep -> Read. Budget: 30 calls / 80KB output. Native tools only. BATCH: issue multiple Read/Glob/Grep calls in a single response when targets are independent. OUTPUT: max 1500 tokens. Bullet list only: '- path/file.ext: one-sentence finding'. No prose preamble, no summary paragraphs, no boilerplate."
    ;;
  Plan)
    GUIDANCE="Pattern: structure -> patterns -> proposal. Budget: 30 calls / 80KB output. Read-only. BATCH: issue multiple Read calls in a single response. OUTPUT: max 2000 tokens. Numbered implementation steps only. No background, rationale, or 'here is my analysis' sections."
    ;;
  general-purpose)
    GUIDANCE="Pattern: explore -> plan -> execute. Budget: 35 calls / 120KB output. No MCP tools. BATCH: issue multiple independent tool calls in a single response to reduce turns. OUTPUT: max 2000 tokens. Concise results only, no narration."
    ;;
  code-reviewer|security-auditor)
    GUIDANCE="Pattern: scope -> grep -> read. Budget: 25-30 calls / 100KB output. Read-only. BATCH: after scoping files, Read ALL target files in a single response (up to 10 parallel Read calls). Never read files one at a time. Think once after each batch, not between each file. OUTPUT: max 2000 tokens. Bullet findings with file:line references. No praise, no boilerplate."
    ;;
  deep-debugger)
    GUIDANCE="Pattern: reproduce -> narrow -> instrument. Budget: 40 calls / 150KB output. BATCH: issue multiple Read/Grep calls in a single response when investigating independent locations. OUTPUT: max 2000 tokens. Root cause + evidence only."
    ;;
  refactor|architect|strategist|nix-expert|git-ops|test-runner)
    GUIDANCE="Follow agent-specific workflow. Budget: 25-35 calls / 100-120KB output. BATCH: issue multiple independent tool calls in a single response. OUTPUT: max 2000 tokens. Concise deliverables only."
    ;;
esac

if [[ -n "$GUIDANCE" ]]; then
  cat << EOF
{
  "hookSpecificOutput": {
    "hookEventName": "SubagentStart",
    "additionalContext": "$GUIDANCE"
  }
}
EOF
fi

exit 0
