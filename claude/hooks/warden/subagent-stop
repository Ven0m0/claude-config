#!/usr/bin/env bash
# subagent-stop: Budget reclamation + metrics + DELAYED cleanup (24hr)
set -euo pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

SUBAGENT_COUNT_FILE="$WARDEN_STATE_DIR/subagent-count"

_warden_read_input || exit 0

IFS=$'\t' read -r AGENT_ID SESSION_ID WORKTREE_PATH < <(
    printf '%s' "$WARDEN_INPUT" | jq -r '[.agent_id // "unknown", .session_id // "", .worktree_path // ""] | @tsv' 2>/dev/null
) || exit 0

AGENT_ID=$(_warden_sanitize_id "$AGENT_ID")
SESSION_ID=$(_warden_sanitize_id "$SESSION_ID")
[[ -z "$AGENT_ID" ]] && AGENT_ID="unknown"

# === BUDGET TRACKING ===
# Use actual cumulative output bytes tracked by post-tool-use (~3.5 bytes/token)
BYTE_FILE="$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID.bytes"
if [[ -f "$BYTE_FILE" ]]; then
  _RAW=$(cat "$BYTE_FILE" 2>/dev/null || echo "0")
  _TOTAL_BYTES="${_RAW%%|*}"
  [[ "$_TOTAL_BYTES" =~ ^[0-9]+$ ]] || _TOTAL_BYTES=0
  if (( _TOTAL_BYTES > 0 )); then
    _warden_budget_update $(( _TOTAL_BYTES * 10 / 35 ))
  fi
fi

# === METRICS COLLECTION ===
START_FILE="$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID.start"
if [ -f "$START_FILE" ]; then
  START_TIME=$(cat "$START_FILE")
  END_TIME=$(date +%s)
  DURATION=$((END_TIME - START_TIME))
  AGENT_TYPE=$(grep 'AGENT_TYPE=' "$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID" 2>/dev/null | head -1 | cut -d= -f2 || echo "unknown")

  # Log to unified agent-stats.csv
  AGENT_STATS="$HOME/.claude/agent-stats.csv"
  if [ ! -f "$AGENT_STATS" ]; then
    echo "timestamp,agent_id,agent_category,agent_type,duration_seconds,session_id,status" > "$AGENT_STATS"
  fi
  echo "$(_warden_date_iso),$AGENT_ID,subagent,$AGENT_TYPE,$DURATION,$SESSION_ID,completed" >> "$AGENT_STATS"

  # Emit to events.jsonl for Loki/Grafana visibility
  _TS=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
  _HAS_WORKTREE="false"; [[ -n "${WORKTREE_PATH:-}" ]] && _HAS_WORKTREE="true"
  _AT_SAFE="${AGENT_TYPE//\"/\\\"}"
  printf '{"timestamp":%d,"event_type":"subagent_stop","tool":"SubagentStop","session_id":"%s","agent_id":"%s","agent_type":"%s","duration_seconds":%d,"has_worktree":%s}\n' \
    "$_TS" "$SESSION_ID" "$AGENT_ID" "$_AT_SAFE" "$DURATION" "$_HAS_WORKTREE" \
    >> "$WARDEN_EVENTS_FILE" 2>/dev/null
fi

# Decrement active subagent count (with cross-platform locking)
if [ -n "$SESSION_ID" ] && [ -f "$SUBAGENT_COUNT_FILE" ]; then
  _decrement_count() {
    IFS='|' read -r PREV_SESSION PREV_COUNT _PREV_TS < "$SUBAGENT_COUNT_FILE"
    if [ "$PREV_SESSION" = "$SESSION_ID" ]; then
      [[ "$PREV_COUNT" =~ ^[0-9]+$ ]] || PREV_COUNT=0
      [ "$PREV_COUNT" -gt 0 ] && PREV_COUNT=$((PREV_COUNT - 1))
      printf '%s|%s|%s\n' "$SESSION_ID" "$PREV_COUNT" "$(date +%s)" > "$SUBAGENT_COUNT_FILE"
    fi
  }
  _warden_with_lock "$WARDEN_STATE_DIR/subagent-count.lock.d" _decrement_count
fi
_warden_write_budget_prom

# NOTE: NO immediate cleanup - state files retained for debugging
# Cleanup handled by cron after 24hr

exit 0
