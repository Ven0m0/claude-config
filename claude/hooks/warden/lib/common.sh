#!/usr/bin/env bash
# claude-warden shared library
# Source this file at the top of hooks to access common utilities
# Cost: ~1ms per source (negligible vs 55-110ms hook overhead)

# ==============================================================================
# ENVIRONMENT SETUP (executed once per hook invocation)
# ==============================================================================

# State directories
export WARDEN_STATE_DIR="${WARDEN_STATE_DIR:-$HOME/.claude/.statusline}"
export WARDEN_SESSION_BUDGET_DIR="${WARDEN_SESSION_BUDGET_DIR:-$HOME/.claude/.session-budgets}"
export WARDEN_SUBAGENT_STATE_DIR="${WARDEN_SUBAGENT_STATE_DIR:-$HOME/.claude/.subagent-state}"
export WARDEN_EVENTS_FILE="$WARDEN_STATE_DIR/events.jsonl"

# ==============================================================================
# CROSS-PLATFORM HELPERS (must be defined before first use)
# ==============================================================================

# Detect platform once
_WARDEN_OS="$(uname -s)"

# Get nanosecond-precision timestamp (epoch nanoseconds as integer)
# macOS date doesn't support %N; falls back to seconds * 10^9
_warden_date_ns() {
    if [[ "$_WARDEN_OS" == "Darwin" ]]; then
        # macOS: use perl for sub-second precision if available, else seconds
        if command -v perl &>/dev/null; then
            perl -MTime::HiRes=time -e 'printf "%d\n", time()*1e9'
        else
            echo "$(date +%s)000000000"
        fi
    else
        date +%s%N
    fi
}

# Get seconds.nanoseconds timestamp (e.g., 1234567890.123456789)
# macOS date doesn't support %N; falls back to seconds.000000000
_warden_date_sns() {
    if [[ "$_WARDEN_OS" == "Darwin" ]]; then
        if command -v perl &>/dev/null; then
            perl -MTime::HiRes=time -e 'printf "%.9f\n", time()'
        else
            echo "$(date +%s).000000000"
        fi
    else
        date +%s.%N
    fi
}

# Get ISO 8601 date string (e.g., 2024-01-15T10:30:00+0000)
# macOS date doesn't support -Iseconds
_warden_date_iso() {
    if [[ "$_WARDEN_OS" == "Darwin" ]]; then
        date -u +%Y-%m-%dT%H:%M:%S%z
    else
        date -Iseconds
    fi
}

# Cross-platform md5 hash (returns 32 hex chars on stdout)
_warden_md5() {
    if command -v md5sum &>/dev/null; then
        md5sum | cut -c1-32
    elif command -v md5 &>/dev/null; then
        md5 -q
    else
        # Fallback: use openssl which is available on both platforms
        openssl md5 -r | cut -c1-32
    fi
}

# Session start timestamp (cached for this invocation)
if [[ -f "$WARDEN_STATE_DIR/.session_start" ]]; then
    _WARDEN_SESSION_START_NS=$(cat "$WARDEN_STATE_DIR/.session_start" 2>/dev/null)
    # Handle both formats: seconds-only and seconds.nanoseconds
    if [[ "$_WARDEN_SESSION_START_NS" == *.* ]]; then
        _WARDEN_SESSION_START_S=$(cut -d. -f1 <<< "$_WARDEN_SESSION_START_NS")
    else
        _WARDEN_SESSION_START_S="$_WARDEN_SESSION_START_NS"
    fi
else
    _WARDEN_SESSION_START_S=$(date +%s)
fi
export _WARDEN_SESSION_START_S

# Current timestamp (captured once)
export _WARDEN_NOW_S=$(date +%s)
export _WARDEN_NOW_NS=$(_warden_date_sns)

# Source warden config if available (generated by install.sh)
# Contains thresholds, subagent budgets, and other tunable values
_WARDEN_CONFIG_ENV="${HOME}/.claude/.warden/warden.env"
if [[ -f "$_WARDEN_CONFIG_ENV" ]]; then
    if bash -n "$_WARDEN_CONFIG_ENV" 2>/dev/null; then
        source "$_WARDEN_CONFIG_ENV"
    else
        printf 'warden: warning: invalid config syntax in "%s"; using defaults\n' "$_WARDEN_CONFIG_ENV" >&2
    fi
fi

# Truncation thresholds (warden.env overrides, or fallback defaults)
export WARDEN_TRUNCATE_BYTES=${WARDEN_TRUNCATE_BYTES:-20480}           # 20KB generic
export WARDEN_SUBAGENT_READ_BYTES=${WARDEN_SUBAGENT_READ_BYTES:-10240} # 10KB subagent
export WARDEN_SUPPRESS_BYTES=${WARDEN_SUPPRESS_BYTES:-524288}          # 500KB suppress
export WARDEN_READ_GUARD_MAX_MB=${WARDEN_READ_GUARD_MAX_MB:-2}
export WARDEN_WRITE_MAX_BYTES=${WARDEN_WRITE_MAX_BYTES:-102400}
export WARDEN_EDIT_MAX_BYTES=${WARDEN_EDIT_MAX_BYTES:-51200}
export WARDEN_NOTEBOOK_MAX_BYTES=${WARDEN_NOTEBOOK_MAX_BYTES:-51200}
export WARDEN_DEFAULT_CALL_LIMIT=${WARDEN_DEFAULT_CALL_LIMIT:-30}
export WARDEN_DEFAULT_BYTE_LIMIT=${WARDEN_DEFAULT_BYTE_LIMIT:-102400}
export WARDEN_BUDGET_TOTAL=${WARDEN_BUDGET_TOTAL:-280000}

# ==============================================================================
# BUILT-IN BUDGET TRACKER
# ==============================================================================
# Tracks estimated token consumption per session (~3.5 bytes/token).
# State: single file with consumed count. Total from WARDEN_BUDGET_TOTAL.

WARDEN_BUDGET_STATE="${HOME}/.claude/.warden/budget.state"
WARDEN_BUDGET_CACHE="$WARDEN_STATE_DIR/budget-export"

# Read consumed tokens from state file (returns number on stdout)
_warden_budget_read() {
    [[ -f "$WARDEN_BUDGET_STATE" ]] || { echo 0; return; }
    local val
    val=$(<"$WARDEN_BUDGET_STATE")
    [[ "$val" =~ ^[0-9]+$ ]] && echo "$val" || echo 0
}

# Write consumed tokens to state file
_warden_budget_write() {
    mkdir -p "$(dirname "$WARDEN_BUDGET_STATE")"
    printf '%d' "$1" > "$WARDEN_BUDGET_STATE"
}

# Add tokens to consumed counter
_warden_budget_update() {
    local tokens="${1:-0}"
    [[ "$tokens" =~ ^[0-9]+$ ]] || return 0
    (( tokens == 0 )) && return 0
    local consumed
    consumed=$(_warden_budget_read)
    consumed=$((consumed + tokens))
    _warden_budget_write "$consumed"
}

# Check if budget is available (exit 0 = ok, exit 1 = exhausted)
_warden_budget_check() {
    local consumed
    consumed=$(_warden_budget_read)
    (( consumed < WARDEN_BUDGET_TOTAL ))
}

# Export budget state as JSON to stdout AND write cache for statusline
_warden_budget_export() {
    local consumed total util
    consumed=$(_warden_budget_read)
    total="$WARDEN_BUDGET_TOTAL"
    util=0
    (( total > 0 )) && util=$((consumed * 100 / total))
    local json
    json=$(printf '{"consumed":%d,"limit":%d,"total_limit":%d,"utilization":%d}' \
        "$consumed" "$total" "$total" "$util")
    echo "$json"
    # Write cache for statusline (non-blocking)
    mkdir -p "$(dirname "$WARDEN_BUDGET_CACHE")"
    printf '%s' "$json" > "$WARDEN_BUDGET_CACHE" 2>/dev/null || true
}

# Reset budget counter (called at session start)
_warden_budget_reset() {
    _warden_budget_write 0
}

# Write Prometheus textfile for node-exporter (budget + subagent metrics).
# Atomic write (tmp + mv). Skips silently if monitoring dir doesn't exist.
_warden_write_budget_prom() {
    local prom_dir="${HOME}/.claude/.monitoring/textfile"
    [[ -d "$prom_dir" ]] || return 0

    local consumed total remaining util active _sc_raw _sc_count
    consumed=$(_warden_budget_read)
    total="$WARDEN_BUDGET_TOTAL"
    remaining=$(( total > consumed ? total - consumed : 0 ))
    util=0; (( total > 0 )) && util=$(( consumed * 100 / total ))

    active=0
    if [[ -f "$WARDEN_STATE_DIR/subagent-count" ]]; then
        _sc_raw=$(<"$WARDEN_STATE_DIR/subagent-count")
        IFS='|' read -r _ _sc_count _ <<< "$_sc_raw"
        [[ "$_sc_count" =~ ^[0-9]+$ ]] && active="$_sc_count"
    fi

    {   printf '# HELP claude_budget_total_tokens Total token budget limit\n'
        printf '# TYPE claude_budget_total_tokens gauge\n'
        printf 'claude_budget_total_tokens %d\n' "$total"
        printf '# HELP claude_budget_consumed_tokens Tokens consumed in current session\n'
        printf '# TYPE claude_budget_consumed_tokens gauge\n'
        printf 'claude_budget_consumed_tokens %d\n' "$consumed"
        printf '# HELP claude_budget_remaining_tokens Tokens remaining in budget\n'
        printf '# TYPE claude_budget_remaining_tokens gauge\n'
        printf 'claude_budget_remaining_tokens %d\n' "$remaining"
        printf '# HELP claude_budget_utilization_percent Budget utilization percentage\n'
        printf '# TYPE claude_budget_utilization_percent gauge\n'
        printf 'claude_budget_utilization_percent %d\n' "$util"
        printf '# HELP claude_budget_active_subagents Number of active subagents\n'
        printf '# TYPE claude_budget_active_subagents gauge\n'
        printf 'claude_budget_active_subagents %d\n' "$active"
    } > "${prom_dir}/budget.prom.tmp" && mv "${prom_dir}/budget.prom.tmp" "${prom_dir}/budget.prom" || true
}

# ==============================================================================
# EXACT TOKEN COUNTING (background, fire-and-forget)
# ==============================================================================
# When WARDEN_TOKEN_COUNT=api, spawn _token-count-bg to get exact counts from the
# Anthropic token counting API. Writes correction events to events.jsonl.
# Zero added hook latency: runs in background with & disown.
# Requires: python3 with anthropic package, ANTHROPIC_API_KEY set by Claude Code.

_warden_fire_token_count() {
    local orig_text="$1" final_text="$2" estimated="$3" rule="$4"
    [[ "${WARDEN_TOKEN_COUNT:-}" != "api" ]] && return
    local python="${WARDEN_PYTHON:-python3}"
    local script="$WARDEN_HOOKS_DIR/_token-count-bg"
    command -v "$python" &>/dev/null || return
    [[ -x "$script" ]] || return

    local tmpdir
    tmpdir=$(mktemp -d "/tmp/warden-tc.XXXXXX") || return
    printf '%s' "$orig_text" > "$tmpdir/orig"
    printf '%s' "$final_text" > "$tmpdir/final"

    local ts=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
    "$python" "$script" \
        "$ts" "${WARDEN_TOOL_NAME:-unknown}" "${WARDEN_COMMAND:0:200}" "$estimated" "$rule" \
        "$WARDEN_EVENTS_FILE" "$tmpdir/orig" "$tmpdir/final" &
    disown
}

# ==============================================================================
# SUBAGENT LIMIT LOOKUPS (Bash 3.2 compatible)
# ==============================================================================
# warden.env exports WARDEN_CALL_LIMIT_<type> and WARDEN_BYTE_LIMIT_<type>
# as individual vars (hyphens replaced with underscores).
# These helpers look up the correct var via indirect expansion.

_warden_call_limit() {
    local type="${1//-/_}"
    local var="WARDEN_CALL_LIMIT_${type}"
    echo "${!var:-$WARDEN_DEFAULT_CALL_LIMIT}"
}

_warden_byte_limit() {
    local type="${1//-/_}"
    local var="WARDEN_BYTE_LIMIT_${type}"
    echo "${!var:-$WARDEN_DEFAULT_BYTE_LIMIT}"
}

# ==============================================================================
# INPUT PARSING
# ==============================================================================

# Parse stdin input with timeout
# Usage: _warden_read_input
# Sets global: WARDEN_INPUT
_warden_read_input() {
    read -r -t 5 -d '' WARDEN_INPUT || true
    export WARDEN_INPUT
    [[ -z "$WARDEN_INPUT" ]] && return 1
    return 0
}

# Two-tier jq extraction optimized for hot path
# Tier 1: Bash extraction for top-level string fields (safe, machine-generated JSON)
# Tier 2: Single jq call for nested fields or non-string types
#
# Usage: _warden_parse_toplevel FIELD_NAME
# Extracts top-level string fields using parameter expansion (10ms faster than jq)
# SAFETY: Only works for top-level string fields in well-formed machine JSON
# ASSUMPTION: Claude Code emits JSON where top-level strings don't contain escaped quotes
_warden_parse_toplevel() {
    local field="$1"
    local value=""

    # Extract using bash parameter expansion: "field":"value"
    if [[ "$WARDEN_INPUT" =~ \"$field\"[[:space:]]*:[[:space:]]*\"([^\"]+)\" ]]; then
        value="${BASH_REMATCH[1]}"
    fi

    printf '%s' "$value"
}

# Fast extraction of common top-level fields (non-Bash fast path)
# Usage: _warden_parse_tool_name
# Returns: tool_name value
_warden_parse_tool_name() {
    _warden_parse_toplevel "tool_name"
}

_warden_parse_session_id() {
    _warden_parse_toplevel "session_id"
}

_warden_parse_transcript_path() {
    _warden_parse_toplevel "transcript_path"
}

# Parse nested tool_input fields (single jq call, returns TSV)
# Usage: IFS=$'\t' read -r VAR1 VAR2 VAR3 < <(_warden_parse_tool_input field1 field2 field3)
_warden_parse_tool_input() {
    local -a fields=("$@")
    local jq_expr='['
    for field in "${fields[@]}"; do
        jq_expr+=".tool_input.$field // \"\", "
    done
    jq_expr="${jq_expr%, }] | @tsv"

    printf '%s' "$WARDEN_INPUT" | jq -r "$jq_expr" 2>/dev/null
}

# ==============================================================================
# ID SANITIZATION
# ==============================================================================

# Sanitize session/agent IDs to prevent path traversal
# Usage: _warden_sanitize_id "$ID"
# Returns: sanitized ID or empty string if invalid
_warden_sanitize_id() {
    local id="$1"
    if [[ "$id" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        printf '%s' "$id"
    fi
}

# ==============================================================================
# SUBAGENT DETECTION
# ==============================================================================

# Detect if current invocation is from a subagent
# Usage: _warden_is_subagent "$TRANSCRIPT_PATH"
# Returns: 0 if subagent, 1 if main agent
_warden_is_subagent() {
    local transcript_path="$1"
    [[ "$transcript_path" == *"/subagents/"* || "$transcript_path" == *"/tmp/"* ]]
}

# Extract agent ID from transcript path
# Usage: _warden_get_agent_id "$TRANSCRIPT_PATH"
# Returns: sanitized agent ID or empty
_warden_get_agent_id() {
    local transcript_path="$1"
    local agent_id=""

    if [[ "$transcript_path" == *"/subagents/"* ]]; then
        agent_id=$(basename "$transcript_path" .jsonl | sed 's/^agent-//')
        agent_id=$(_warden_sanitize_id "$agent_id")
    fi

    printf '%s' "$agent_id"
}

# Get agent type from state file
# Usage: _warden_get_agent_type "$AGENT_ID"
# Returns: agent type or empty
_warden_get_agent_type() {
    local agent_id="$1"
    local agent_type=""

    if [[ -n "$agent_id" && -f "$WARDEN_SUBAGENT_STATE_DIR/$agent_id" ]]; then
        agent_type=$(grep '^AGENT_TYPE=' "$WARDEN_SUBAGENT_STATE_DIR/$agent_id" 2>/dev/null | head -1 | cut -d= -f2)
    fi

    printf '%s' "$agent_type"
}

# ==============================================================================
# EVENT EMISSION
# ==============================================================================

# Scrub potential secrets from command strings
# Usage: echo "$text" | _warden_scrub_secrets
_warden_scrub_secrets() {
    sed -E \
        's/(-H|--header) +[^ ]+/\1 [REDACTED]/g;
         s/(Bearer |Authorization: ?)[^ ]+/\1[REDACTED]/gi;
         s/([a-zA-Z_]*(key|secret|token|password|credential|api_key|database_url|client_id|client_secret|access_token|refresh_token)[a-zA-Z_]*)=[^ ]+/\1=[REDACTED]/gi;
         s/(ghp_|github_pat_|sk-|gho_|glpat-|xox[bpsa]-)[^ ]+/[REDACTED]/g'
}

# Scrub secrets from a variable in-place if it looks like it may contain them
# Usage: _warden_maybe_scrub cmd_safe
# Bash 3.2 compatible: uses ${!var} indirect read + printf -v write (no local -n)
_warden_maybe_scrub() {
    local _varname=$1
    local _val="${!_varname}"
    # Case-insensitive check via shopt (scoped to this function via subshell-free restore)
    local _prev_nocasematch
    _prev_nocasematch=$(shopt -p nocasematch 2>/dev/null || true)
    shopt -s nocasematch
    if [[ "$_val" =~ (-H|--header|bearer|authorization|token|key=|secret=|password=|credential=|database_url=|client_id=|client_secret=|access_token=|ghp_|github_pat_|sk-|gho_|glpat-|xox[bpsa]-) ]]; then
        printf -v "$_varname" '%s' "$(printf '%s' "$_val" | _warden_scrub_secrets)"
    fi
    eval "$_prev_nocasematch" 2>/dev/null || true
}

# Emit JSONL event for blocked commands (pre-tool-use)
# Usage: _warden_emit_block RULE TOKENS_SAVED [CMD_OVERRIDE]
_warden_emit_block() {
    local rule="$1" tokens="$2" cmd_override="${3:-}"
    local ts=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
    local cmd_safe="${cmd_override:-${WARDEN_COMMAND:0:200}}"

    # Sanitize command for JSON
    cmd_safe="${cmd_safe//$'\n'/ }"
    cmd_safe="${cmd_safe//\\/\\\\}"
    cmd_safe="${cmd_safe//\"/\\\"}"

    _warden_maybe_scrub cmd_safe

    printf '{"timestamp":%d,"event_type":"blocked","tool":"%s","session_id":"%s","original_cmd":"%s","rule":"%s","tokens_saved":%d}\n' \
        "$ts" "${WARDEN_TOOL_NAME:-unknown}" "${WARDEN_SESSION_ID:-}" "$cmd_safe" "$rule" "$tokens" \
        >> "$WARDEN_EVENTS_FILE" 2>/dev/null
}

# Emit JSONL event for post-tool-use accounting
# Usage: _warden_emit_event EVENT_TYPE ORIG_BYTES FINAL_BYTES [RULE]
_warden_emit_event() {
    local etype="$1" orig_bytes="$2" final_bytes="$3" rule="${4:-}"

    # 3.5 bytes/token average
    local saved=$(( (orig_bytes - final_bytes) * 10 / 35 ))
    (( saved < 0 )) && saved=0

    local ts=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
    local rule_field=""
    [[ -n "$rule" ]] && rule_field="$(printf ',"rule":"%s"' "$rule")"

    local cmd_safe="${WARDEN_COMMAND:0:200}"
    cmd_safe="${cmd_safe//$'\n'/ }"
    cmd_safe="${cmd_safe//\\/\\\\}"
    cmd_safe="${cmd_safe//\"/\\\"}"

    _warden_maybe_scrub cmd_safe

    printf '{"timestamp":%d,"event_type":"%s","tool":"%s","session_id":"%s","original_cmd":"%s","tokens_saved":%d,"original_output_bytes":%d,"final_output_bytes":%d%s}\n' \
        "$ts" "$etype" "${WARDEN_TOOL_NAME:-unknown}" "${WARDEN_SESSION_ID:-}" "$cmd_safe" "$saved" "$orig_bytes" "$final_bytes" "$rule_field" \
        >> "$WARDEN_EVENTS_FILE" 2>/dev/null
}

# Emit JSONL event for tool output size tracking
# Usage: _warden_emit_output_size TOOL_NAME OUTPUT_BYTES OUTPUT_LINES CMD
_warden_emit_output_size() {
    local tool_name="$1" output_bytes="$2" output_lines="${3:-0}" cmd="${4:-}"
    local ts=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))

    local estimated_tokens=$(( output_bytes * 10 / 35 ))

    local cmd_safe="${cmd:0:200}"
    cmd_safe="${cmd_safe//$'\n'/ }"
    cmd_safe="${cmd_safe//\\/\\\\}"
    cmd_safe="${cmd_safe//\"/\\\"}"

    _warden_maybe_scrub cmd_safe

    local sid="${WARDEN_SESSION_ID:-}"
    printf '{"timestamp":%d,"event_type":"tool_output_size","tool":"%s","session_id":"%s","output_bytes":%d,"output_lines":%d,"estimated_tokens":%d,"original_cmd":"%s"}\n' \
        "$ts" "$tool_name" "$sid" "$output_bytes" "$output_lines" "$estimated_tokens" "$cmd_safe" \
        >> "$WARDEN_EVENTS_FILE" 2>/dev/null
}

# ==============================================================================
# SYSTEM REMINDER STRIPPING
# ==============================================================================

# Strip <system-reminder> blocks from text
# Usage: _warden_strip_reminders VAR_NAME
# Returns: cleaned text via stdout
# Bash 3.2 compatible: uses ${!1} indirect read (no local -n)
_warden_strip_reminders() {
    local text_ref="${!1}"
    local cleaned

    cleaned=$(printf '%s' "${text_ref}" | sed '/^<system-reminder>/,/^<\/system-reminder>/d')
    # Trim trailing blank lines: BSD sed branch labels don't work cross-platform; awk does
    cleaned=$(printf '%s' "$cleaned" | awk 'NF{found=NR} {a[NR]=$0} END{for(i=1;i<=found;i++)print a[i]}')

    printf '%s' "$cleaned"
}

# ==============================================================================
# FILE UTILITIES
# ==============================================================================

# Get file modification time
# Usage: _warden_stat_mtime "$FILE_PATH"
# Returns: mtime in seconds
_warden_stat_mtime() {
    local file="$1"
    stat -c%Y "$file" 2>/dev/null || stat -f%m "$file" 2>/dev/null || echo 0
}

# ==============================================================================
# AGENT STATS
# ==============================================================================

# Append to unified agent stats CSV
# Usage: _warden_agent_stats_append AGENT_ID AGENT_CATEGORY AGENT_TYPE DURATION STATUS
_warden_agent_stats_append() {
    local agent_id="$1" category="$2" type="$3" duration="$4" status="$5"
    local agent_stats="$HOME/.claude/agent-stats.csv"
    local session_id="${WARDEN_SESSION_ID:-unknown}"

    # Initialize CSV with header if needed
    if [[ ! -f "$agent_stats" ]]; then
        echo "timestamp,agent_id,agent_category,agent_type,duration_seconds,session_id,status" > "$agent_stats"
    fi

    echo "$(_warden_date_iso),$agent_id,$category,$type,$duration,$session_id,$status" >> "$agent_stats"
}

# ==============================================================================
# NOTIFICATIONS
# ==============================================================================

# Cross-platform notification
# Usage: _warden_notify URGENCY TITLE BODY
_warden_notify() {
    local urgency="$1" title="$2" body="$3"
    if command -v notify-send &>/dev/null; then
        notify-send -u "$urgency" "$title" "$body"
    elif command -v osascript &>/dev/null; then
        osascript -e "display notification \"$body\" with title \"$title\""
    fi
}

# ==============================================================================
# HOOK OUTPUT HELPERS
# ==============================================================================

# Suppress output (pass through)
_warden_suppress_ok() {
    echo '{"suppressOutput":true}'
    exit 0
}

# Deny with reason (PreToolUse)
_warden_deny() {
    local reason="$1"
    printf '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"deny","permissionDecisionReason":"%s"}}\n' "$reason"
    exit 0
}

# ==============================================================================
# INLINE AGENT VALIDATIONS (from agents/)
# ==============================================================================

# Redact secrets from tool output (PostToolUse)
# Usage: _warden_check_secrets "$RESPONSE_TEXT"
# Returns: 0 if secrets found, 1 if clean
_warden_check_secrets() {
    local response="$1"
    local secret_patterns='(AKIA[0-9A-Z]{16}|eyJ[A-Za-z0-9_-]+\.eyJ|-----BEGIN .* PRIVATE KEY-----|api[_-]?key.*=.*[a-zA-Z0-9]{20,})'

    if printf '%s' "$response" | grep -qiE "$secret_patterns"; then
        return 0
    fi
    return 1
}

# Validate readonly for code-reviewer agents (PreToolUse)
# Usage: _warden_validate_readonly "$COMMAND"
# Returns: 0 if allowed, 1 if blocked
_warden_validate_readonly() {
    local command="$1"
    # Fixed bug #7: include BOL redirects with (^|[^-])>
    local write_patterns='(\brm\b|\brmdir\b|\bmv\b|\bcp\b|(^|[^-])>|>>|\btee\b|sed -i|\bchmod\b|\bchown\b|\btruncate\b|\bdd\b|\binstall\b|rsync.*--delete|\bpatch\b|git checkout -- |git restore|\bunlink\b|\bshred\b|\btouch\b|\bln\b|\bmkdir\b)'

    if printf '%s' "$command" | grep -qiE "$write_patterns"; then
        return 1
    fi
    return 0
}

# Validate git commands (PreToolUse)
# Usage: _warden_validate_git "$COMMAND"
# Returns: 0 if allowed, 1 if blocked (with stderr message)
_warden_validate_git() {
    local command="$1"

    # Block dangerous git operations
    if printf '%s' "$command" | grep -qiE '(git push.*--force|git push.*-f|git reset --hard|git clean -fd|git clean -f)'; then
        if printf '%s' "$command" | grep -qiE '(main|master|origin)'; then
            echo "Blocked: Force push/reset to main/master requires explicit user approval" >&2
            return 1
        fi
    fi

    # Block git config writes
    if printf '%s' "$command" | grep -qiE 'git config'; then
        if printf '%s' "$command" | grep -qiE '(--get|--get-all|--list|-l|--show-origin)'; then
            return 0  # Read-only, allow
        elif printf '%s' "$command" | grep -qiE '(user\.|email|name|credential)'; then
            echo "Blocked: Git config writes not allowed" >&2
            return 1
        fi
    fi

    return 0
}

# ==============================================================================
# TOOL LATENCY TRACKING
# ==============================================================================

# Record tool start timestamp for latency measurement
# Usage: _warden_record_tool_start "$TOOL_NAME"
# Writes nanosecond timestamp to state file
_warden_record_tool_start() {
    local tool_name="$1"
    [[ -z "$tool_name" ]] && return
    mkdir -p "$WARDEN_STATE_DIR"
    _warden_date_ns > "$WARDEN_STATE_DIR/.tool-start-${tool_name}-$$" 2>/dev/null
}

# Compute tool latency from recorded start timestamp
# Usage: _warden_compute_tool_latency "$TOOL_NAME"
# Sets: WARDEN_TOOL_LATENCY_MS (integer ms), WARDEN_TOOL_START_NS, WARDEN_TOOL_END_NS
# Returns: 0 if computed, 1 if no start timestamp found
_warden_compute_tool_latency() {
    local tool_name="$1"
    WARDEN_TOOL_LATENCY_MS=""
    WARDEN_TOOL_START_NS=""
    WARDEN_TOOL_END_NS=""

    # Find the most recent start file for this tool (any PID)
    local start_file=""
    local newest_file=""
    local newest_mtime=0
    for f in "$WARDEN_STATE_DIR"/.tool-start-"${tool_name}"-*; do
        [[ -f "$f" ]] || continue
        local mtime
        mtime=$(_warden_stat_mtime "$f")
        if (( mtime > newest_mtime )); then
            newest_mtime=$mtime
            newest_file="$f"
        fi
    done
    start_file="$newest_file"

    [[ -z "$start_file" || ! -f "$start_file" ]] && return 1

    WARDEN_TOOL_START_NS=$(cat "$start_file" 2>/dev/null)
    rm -f "$start_file" 2>/dev/null

    [[ ! "$WARDEN_TOOL_START_NS" =~ ^[0-9]+$ ]] && return 1

    WARDEN_TOOL_END_NS=$(_warden_date_ns)
    local delta_ns=$(( WARDEN_TOOL_END_NS - WARDEN_TOOL_START_NS ))
    WARDEN_TOOL_LATENCY_MS=$(( delta_ns / 1000000 ))

    # Sanity: reject negative or absurdly large (>10min) values
    if (( WARDEN_TOOL_LATENCY_MS < 0 || WARDEN_TOOL_LATENCY_MS > 600000 )); then
        WARDEN_TOOL_LATENCY_MS=""
        return 1
    fi

    export WARDEN_TOOL_LATENCY_MS WARDEN_TOOL_START_NS WARDEN_TOOL_END_NS
    return 0
}

# Emit tool latency event to events.jsonl
# Usage: _warden_emit_latency "$TOOL_NAME" "$LATENCY_MS" "$COMMAND"
_warden_emit_latency() {
    local tool_name="$1" latency_ms="$2" cmd="${3:-}"
    local ts=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))

    local cmd_safe="${cmd:0:200}"
    cmd_safe="${cmd_safe//$'\n'/ }"
    cmd_safe="${cmd_safe//\\/\\\\}"
    cmd_safe="${cmd_safe//\"/\\\"}"

    _warden_maybe_scrub cmd_safe

    printf '{"timestamp":%d,"event_type":"tool_latency","tool":"%s","session_id":"%s","duration_ms":%d,"original_cmd":"%s","rule":"hook_measured"}\n' \
        "$ts" "$tool_name" "${WARDEN_SESSION_ID:-}" "$latency_ms" "$cmd_safe" \
        >> "$WARDEN_EVENTS_FILE" 2>/dev/null
}

# ==============================================================================
# INITIALIZATION COMPLETE
# ==============================================================================
# Library loaded. Hooks can now use all _warden_* functions.
