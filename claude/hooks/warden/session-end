#!/usr/bin/env bash
# session-end: Track terminal agent completion and session cleanup
set -euo pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

LOG_FILE="$HOME/.claude/session-log.txt"
RESET_REASON_FILE="$WARDEN_STATE_DIR/reset-reason"
AGENT_STATS="$HOME/.claude/agent-stats.csv"
SESSION_COST_LOG="$HOME/.claude/.monitoring/session-costs.csv"

_warden_read_input || exit 0

# Extract session info
IFS=$'\t' read -r SESSION_ID REASON < <(
    printf '%s' "$WARDEN_INPUT" | jq -r '[.session_id // "unknown", .reason // ""] | @tsv' 2>/dev/null
) || exit 0
SESSION_ID=$(_warden_sanitize_id "$SESSION_ID")
[[ -z "$SESSION_ID" ]] && SESSION_ID="unknown"

# Calculate terminal agent duration
SESSION_START_FILE="$HOME/.claude/.session-times/$SESSION_ID.start"
if [ -f "$SESSION_START_FILE" ]; then
  START_EPOCH=$(cat "$SESSION_START_FILE")
  END_EPOCH=$(date +%s)
  DURATION=$((END_EPOCH - START_EPOCH))
  DURATION_MIN=$((DURATION / 60))

  # Log terminal agent completion
  echo "$(_warden_date_iso),terminal-$SESSION_ID,terminal,main,$DURATION,$SESSION_ID,completed" >> "$AGENT_STATS"

  # Emit session_end event to events.jsonl for Loki/Grafana
  _TS=$((_WARDEN_NOW_S - _WARDEN_SESSION_START_S))
  printf '{"timestamp":%d,"event_type":"session_end","tool":"SessionEnd","session_id":"%s","duration_seconds":%d}\n' \
    "$_TS" "$SESSION_ID" "$DURATION" \
    >> "$WARDEN_EVENTS_FILE" 2>/dev/null

  # Emit root OTLP trace span â€” closes the waterfall; Tempo stitches tool spans to it
  START_NS_FILE="$HOME/.claude/.session-times/$SESSION_ID.start_ns"
  if [[ -f "$START_NS_FILE" ]] && [[ -f "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh" ]]; then
    source "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh"
    SESSION_START_NS=$(cat "$START_NS_FILE")
    SESSION_END_NS=$(_warden_date_sns)
    _warden_emit_root_span "$SESSION_ID" "$SESSION_START_NS" "$SESSION_END_NS" & disown
    rm -f "$START_NS_FILE"
  fi

  # Track budget delta for this session
  START_BUDGET_FILE="$WARDEN_SESSION_BUDGET_DIR/$SESSION_ID.start.json"
  if [ -f "$START_BUDGET_FILE" ]; then
    START_CONSUMED=$(jq -r '.consumed // 0' "$START_BUDGET_FILE" 2>/dev/null || echo 0)
    END_JSON=$(_warden_budget_export)
    END_CONSUMED=$(echo "$END_JSON" | jq -r '.consumed // 0')
    DELTA=$((END_CONSUMED - START_CONSUMED))

    # Initialize CSV if needed
    mkdir -p "$(dirname "$SESSION_COST_LOG")"
    if [ ! -f "$SESSION_COST_LOG" ]; then
      echo "timestamp,session_id,duration_seconds,budget_start,budget_end,budget_delta,subagent_count" > "$SESSION_COST_LOG"
    fi

    # Count subagents for this session
    SUBAGENT_COUNT=$(grep ",$SESSION_ID," "$AGENT_STATS" 2>/dev/null | grep ",subagent," | grep ",completed" | awk 'END{print NR}' || echo 0)

    # Log session cost
    echo "$(_warden_date_iso),$SESSION_ID,$DURATION,$START_CONSUMED,$END_CONSUMED,$DELTA,$SUBAGENT_COUNT" >> "$SESSION_COST_LOG"

    # Cleanup budget snapshot
    rm -f "$START_BUDGET_FILE"
  fi
else
  DURATION="unknown"
  DURATION_MIN="unknown"
fi

END_TIME=$(date '+%Y-%m-%d %H:%M:%S')

# === GHOST SUBAGENT REAPER ===
# Clean up orphaned subagent state from THIS session only (safe with concurrent sessions)
if [[ -d "$WARDEN_SUBAGENT_STATE_DIR" ]]; then
    for state_file in "$WARDEN_SUBAGENT_STATE_DIR"/*; do
        [ -f "$state_file" ] && [ ! -L "$state_file" ] || continue
        [[ "$(basename "$state_file")" == *.* ]] && continue  # skip .start and session- files
        grep -q "^SESSION_ID=${SESSION_ID}$" "$state_file" 2>/dev/null || continue
        rm -f "$state_file" "$state_file.start"
    done
fi

# === STATE FILE CLEANUP ===
# Purge stale state files older than 24 hours
if [[ -d "$WARDEN_STATE_DIR" ]]; then
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'tool-count-*' -mtime +0 -exec rm -f {} + 2>/dev/null || true
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'tool-top-*' -mtime +0 -exec rm -f {} + 2>/dev/null || true
    find "$WARDEN_STATE_DIR" -maxdepth 1 -type f -name 'session-*' -mtime +0 -exec rm -f {} + 2>/dev/null || true
fi
if [[ -d "$WARDEN_SUBAGENT_STATE_DIR" ]]; then
    find "$WARDEN_SUBAGENT_STATE_DIR" -maxdepth 1 -type f -name '*.start' -mtime +0 -exec rm -f {} + 2>/dev/null || true
    find "$WARDEN_SUBAGENT_STATE_DIR" -maxdepth 1 -type f ! -name '.*' -mtime +0 -exec rm -f {} + 2>/dev/null || true
fi

# Log session end
echo "[$END_TIME] Session ended: $SESSION_ID (duration: ${DURATION_MIN}m, dir: $PWD, reason: $REASON)" >> "$LOG_FILE"

# Record reset reason for statusline
if [ -n "$REASON" ]; then
    mkdir -p "$WARDEN_STATE_DIR"
    printf '%s|%s|%s\n' "$(date +%s)" "$REASON" "$SESSION_ID" > "$RESET_REASON_FILE"
fi

exit 0
