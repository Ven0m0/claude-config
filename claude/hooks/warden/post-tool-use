#!/usr/bin/env bash
# post-tool-use: Track session stats, truncate/suppress large Bash outputs
# Single state file per session, minimal I/O

set -o pipefail

# Source shared library
source "${BASH_SOURCE[0]%/*}/lib/common.sh"

_warden_read_input || exit 0

# Single jq call: extract all needed fields
read -r TOOL_NAME SESSION_ID OUTPUT_SIZE COMMAND < <(
    printf '%s' "$WARDEN_INPUT" | jq -r '[
        .tool_name // "",
        .session_id // "",
        (.tool_response.content[0].text // "" | length),
        (.tool_input.command // .tool_input.file_path // .tool_input.pattern // .tool_input.prompt // "")[0:200]
    ] | @tsv' 2>/dev/null
) || exit 0

# Export for shared library functions (sanitize session_id to prevent path traversal)
export WARDEN_TOOL_NAME="$TOOL_NAME"
export WARDEN_COMMAND="$COMMAND"
export WARDEN_SESSION_ID="$(_warden_sanitize_id "$SESSION_ID")"

[[ "$OUTPUT_SIZE" =~ ^[0-9]+$ ]] || OUTPUT_SIZE=0

# === TOOL OUTPUT SIZE TRACKING (Phase 1 observability) ===
# Emit for all tool calls to build baseline data before enforcement
if (( OUTPUT_SIZE > 0 )); then
    # Count lines (fast approximation: count newlines in first 50KB)
    OUTPUT_LINES=0
    if (( OUTPUT_SIZE <= 51200 )); then
        OUTPUT_LINES=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // "" | if . == "" then 0 elif endswith("\n") then split("\n") | length - 1 else split("\n") | length end' 2>/dev/null)
    else
        # For large outputs, sample first 50KB for line count estimate
        OUTPUT_LINES=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null | head -c 51200 | awk 'END{print NR}')
        # Validate before arithmetic to avoid bash errors on non-numeric input
        [[ "$OUTPUT_LINES" =~ ^[0-9]+$ ]] || OUTPUT_LINES=0
        # Extrapolate
        OUTPUT_LINES=$(( OUTPUT_LINES * OUTPUT_SIZE / 51200 ))
    fi
    [[ "$OUTPUT_LINES" =~ ^[0-9]+$ ]] || OUTPUT_LINES=0
    _warden_emit_output_size "$TOOL_NAME" "$OUTPUT_SIZE" "$OUTPUT_LINES" "$COMMAND"
fi

# === Session state: single file, single read+write ===
if [[ -n "$WARDEN_SESSION_ID" ]]; then
    STATE_FILE="$WARDEN_STATE_DIR/session-$WARDEN_SESSION_ID"
    mkdir -p "$WARDEN_STATE_DIR"

    # Read previous state (count|top_bytes|top_label|timestamp)
    PREV_COUNT=0; PREV_BYTES=0; PREV_LABEL=""; PREV_TS=0
    if [[ -f "$STATE_FILE" ]]; then
        IFS='|' read -r PREV_COUNT PREV_BYTES PREV_LABEL PREV_TS < "$STATE_FILE" 2>/dev/null
    fi
    [[ "$PREV_COUNT" =~ ^[0-9]+$ ]] || PREV_COUNT=0
    [[ "$PREV_BYTES" =~ ^[0-9]+$ ]] || PREV_BYTES=0

    NEW_COUNT=$((PREV_COUNT + 1))

    # Build tool label for top-output tracking
    TOP_LABEL="$PREV_LABEL"
    TOP_BYTES="$PREV_BYTES"
    if (( OUTPUT_SIZE > PREV_BYTES )); then
        TOP_BYTES="$OUTPUT_SIZE"
        if [[ "$TOOL_NAME" == "Bash" && -n "$COMMAND" ]]; then
            CMD="${COMMAND#"${COMMAND%%[![:space:]]*}"}"
            TOP_LABEL="Bash:${CMD%%[[:space:]]*}"
        else
            TOP_LABEL="$TOOL_NAME"
        fi
    fi
    # Sanitize TOP_LABEL for pipe delimiter (prevents state file corruption)
    TOP_LABEL="${TOP_LABEL//|/_}"

    # Single write: count|top_bytes|top_label|timestamp
    printf '%s|%s|%s|%s\n' "$NEW_COUNT" "$TOP_BYTES" "$TOP_LABEL" "$(date +%s)" > "$STATE_FILE"

    # Budget check every 50 calls (infrequent, fine to be slow)
    if (( NEW_COUNT % 50 == 0 )); then
        ALERT_FILE="$WARDEN_STATE_DIR/budget-alert"
        UTIL=$(_warden_budget_export 2>/dev/null | jq -r '.utilization // 0' | cut -d. -f1)
        if [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 90 )); then
            echo "CRITICAL|$UTIL|$(date +%s)" > "$ALERT_FILE"
            _warden_notify critical "Claude Budget" "${UTIL}%!"
        elif [[ "$UTIL" =~ ^[0-9]+$ ]] && (( UTIL >= 75 )); then
            PREV_LEVEL=$(cut -d'|' -f1 < "$ALERT_FILE" 2>/dev/null || echo "")
            [[ "$PREV_LEVEL" != "WARNING" && "$PREV_LEVEL" != "CRITICAL" ]] && {
                echo "WARNING|$UTIL|$(date +%s)" > "$ALERT_FILE"
                _warden_notify normal "Claude Budget" "${UTIL}%"
            }
        fi
    fi
fi

# === SUBAGENT DETECTION + CUMULATIVE BYTE TRACKING ===
TRANSCRIPT_PATH=$(_warden_parse_transcript_path)
IS_SUBAGENT=false
AGENT_ID=""

if _warden_is_subagent "$TRANSCRIPT_PATH"; then
    IS_SUBAGENT=true
    AGENT_ID=$(_warden_get_agent_id "$TRANSCRIPT_PATH")
fi

if [[ "$IS_SUBAGENT" == true && -n "$AGENT_ID" ]]; then
    BYTE_FILE="$WARDEN_SUBAGENT_STATE_DIR/$AGENT_ID.bytes"
    PREV_BYTES=0
    if [[ -f "$BYTE_FILE" ]]; then
        RAW=$(cat "$BYTE_FILE" 2>/dev/null || echo "0")
        if [[ "$RAW" == *"|"* ]]; then
            PREV_BYTES=$(echo "$RAW" | cut -d'|' -f1)
        fi
        [[ ! "$PREV_BYTES" =~ ^[0-9]+$ ]] && PREV_BYTES=0
    fi
    NEW_BYTES=$((PREV_BYTES + OUTPUT_SIZE))
    printf '%s|%s|%s\n' "$NEW_BYTES" "$TOOL_NAME" "$(date +%s)" > "$BYTE_FILE"
fi

# === TOOL LATENCY + TRACE SPAN ===
if _warden_compute_tool_latency "$TOOL_NAME"; then
    _warden_emit_latency "$TOOL_NAME" "$WARDEN_TOOL_LATENCY_MS" "$COMMAND"

    # Emit OTLP trace span (fire-and-forget)
    if [[ -f "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh" ]]; then
        source "${BASH_SOURCE[0]%/*}/lib/otel-trace.sh"
        _warden_emit_trace_span \
            "$TOOL_NAME" \
            "$WARDEN_TOOL_START_NS" \
            "$WARDEN_TOOL_END_NS" \
            "$SESSION_ID" \
            "$COMMAND" \
            "$OUTPUT_SIZE" &
        disown
    fi
fi

# === SYSTEM REMINDER STRIP (all tools) ===
# <system-reminder> blocks are injected into tool_response text by Claude Code infra.
# They repeat per-call and compound across sessions. Strip before any further processing.
REMINDER_PRE_STRIPPED=false
if (( OUTPUT_SIZE > 50 )); then
    _RAW=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
    case "$_RAW" in
        *'<system-reminder>'*)
            _CLEANED=$(printf '%s' "$_RAW" | sed '/^<system-reminder>/,/^<\/system-reminder>/d')
            # Also strip trailing blank lines left by removal (awk for BSD sed compat)
            _CLEANED=$(printf '%s' "$_CLEANED" | awk 'NF{found=NR} {a[NR]=$0} END{for(i=1;i<=found;i++)print a[i]}')
            _CLEANED_SIZE=${#_CLEANED}
            _STRIPPED=$(( ${#_RAW} - _CLEANED_SIZE ))
            if (( _STRIPPED > 0 )); then
                _EMIT_ORIG_TEXT="$_RAW" _EMIT_FINAL_TEXT="$_CLEANED" \
                _warden_emit_event "truncated" "$OUTPUT_SIZE" "$_CLEANED_SIZE" "system_reminder"
                _warden_fire_token_count "$_RAW" "$_CLEANED" "$(( _STRIPPED * 10 / 35 ))" "system_reminder"
                case "$TOOL_NAME" in
                    Bash|Grep|Glob|Task)
                        # Pre-clean for downstream truncation logic
                        OUTPUT="$_CLEANED"
                        OUTPUT_SIZE="$_CLEANED_SIZE"
                        REMINDER_PRE_STRIPPED=true
                        ;;
                    *)
                        # All other tools (Read/Write/Edit/etc): emit cleaned output, done
                        jq -n --arg text "$_CLEANED" '{"modifyOutput":$text}'
                        exit 0
                        ;;
                esac
            fi
            ;;
    esac
    unset _RAW _CLEANED _CLEANED_SIZE _STRIPPED
fi

# === SSH OUTPUT CLEANING ===
# Strip frida banner, normalize repeated auth failures, remove SSH connection noise.
# Runs before generic truncation so banner bytes don't count toward threshold.
if [[ "$TOOL_NAME" == "Bash" ]] && [[ "$COMMAND" == *"ssh"* || "$COMMAND" == *"scp"* || "$COMMAND" == *"frida"* ]]; then
    if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
        OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
        OUTPUT_SIZE=${#OUTPUT}
        REMINDER_PRE_STRIPPED=true
    fi

    _SSH_ORIG_SIZE="$OUTPUT_SIZE"

    # Strip frida ASCII banner lines (present on both success and failure)
    OUTPUT=$(printf '%s' "$OUTPUT" | sed \
        -e '/^[[:space:]]*____$/d' \
        -e '/^[[:space:]]*\/ _  |/d' \
        -e '/^[[:space:]]*| (_| |/d' \
        -e '/^[[:space:]]*> _  |/d' \
        -e '/^[[:space:]]*\/_\/ |_|/d' \
        -e '/^[[:space:]]*help[[:space:]]*->/d' \
        -e '/^[[:space:]]*object[[:space:]]*->/d' \
        -e '/^[[:space:]]*quit[[:space:]]*->/d' \
        -e '/^[[:space:]]*exit[/[:space:]]/d' \
        -e '/^[[:space:]]*export[[:space:]]*->/d' \
        -e '/^[[:space:]]*eval[[:space:]]*->/d' \
        -e '/^[[:space:]]*resume[[:space:]]*->/d' \
        -e '/^[[:space:]]*load[[:space:]]*->/d' \
        -e '/^[[:space:]]*reload[[:space:]]*->/d' \
        -e '/^[[:space:]]*import[[:space:]]*->/d')

    # Strip SSH connection noise (zero-value lines)
    OUTPUT=$(printf '%s' "$OUTPUT" | sed \
        -e '/^Warning: Permanently added/d' \
        -e '/^Pseudo-terminal will not be allocated/d' \
        -e '/^X11 forwarding request failed/d')

    # Collapse repeated auth failure messages into one line
    if printf '%s' "$OUTPUT" | grep -qE "UNIX authentication refused|Host key verification failed"; then
        OUTPUT=$(printf '%s' "$OUTPUT" | awk '
            /UNIX authentication refused/  { if (auth_seen == 0) { print "[SSH: auth refused]"; auth_seen = 1 }; next }
            /Permission denied, please try again/ { next }
            /Host key verification failed/ { if (hkv_seen == 0) { print "[SSH: host key verification failed]"; hkv_seen = 1 }; next }
            /scp: Connection closed/       { next }
            /Connection closed by/         { next }
            { print }
        ')
    fi

    # IPS crash log compression: keep metadata header + exception section, drop threads array.
    # Format: line 1 = JSON header, line 2+ = JSON body with threads array (90%+ of size).
    _IPS_HEADER=$(printf '%s' "$OUTPUT" | head -1)
    if printf '%s' "$_IPS_HEADER" | grep -q '^{"app_name":'; then
        _IPS_BODY=$(printf '%s' "$OUTPUT" | tail -n +2 | awk '
            /"threads"[[:space:]]*:/ { print "  \"threads\": [... omitted ...]"; found=1; next }
            found { next }
            { print }
        ')
        OUTPUT="${_IPS_HEADER}
${_IPS_BODY}
[crash log: threads array omitted]"
    fi
    unset _IPS_HEADER _IPS_BODY

    OUTPUT_SIZE=${#OUTPUT}
    _SSH_CLEANED=true
    if (( OUTPUT_SIZE < _SSH_ORIG_SIZE )); then
        _warden_emit_event "truncated" "$_SSH_ORIG_SIZE" "$OUTPUT_SIZE" "ssh_noise"
    fi
    unset _SSH_ORIG_SIZE
fi

# === GIT HINT STRIP (Bash commands) ===
# git writes "hint:" boilerplate to both stdout and stderr; via 2>&1 the block
# appears twice. Claude knows the workflow -- strip before context accumulation.
if [[ "$TOOL_NAME" == "Bash" ]]; then
    case "$WARDEN_INPUT" in
        *'hint: '*)
            if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
                OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
                OUTPUT_SIZE=${#OUTPUT}
            fi
            _GIT_CLEANED=$(printf '%s' "$OUTPUT" | grep -v '^hint: ')
            if (( ${#_GIT_CLEANED} < OUTPUT_SIZE )); then
                _EMIT_ORIG_TEXT="$OUTPUT" _EMIT_FINAL_TEXT="$_GIT_CLEANED" \
                _warden_emit_event "truncated" "$OUTPUT_SIZE" "${#_GIT_CLEANED}" "git_hints"
                OUTPUT="$_GIT_CLEANED"
                OUTPUT_SIZE="${#_GIT_CLEANED}"
                REMINDER_PRE_STRIPPED=true
            fi
            unset _GIT_CLEANED
            ;;
    esac
fi

# Truncate large outputs from Bash, Grep, Glob, Task (Read handled by read-compress)
# Subagent Reads also fall through: safety net when read-compress fails
case "$TOOL_NAME" in
    Bash|Grep|Glob|Task) ;;
    Read)
        if [[ "$IS_SUBAGENT" != true ]]; then
            _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _warden_suppress_ok
        fi
        ;;
    *) _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _warden_suppress_ok ;;
esac

# Helper: emit cleaned output if reminders were stripped, else suppress (pass through)
_exit_clean_or_suppress() {
    if [[ "$REMINDER_PRE_STRIPPED" == true ]]; then
        jq -n --arg text "$OUTPUT" '{"modifyOutput":$text}'
        exit 0
    fi
    _warden_suppress_ok
}

# Task-specific: extract structured lines instead of blind head+tail
# Agent results are prose-heavy but the useful content is bullets, steps, headers, file refs
# Runs BEFORE fast path since agent results (6-15KB) fall under the 20KB generic threshold
if [[ "$TOOL_NAME" == "Task" ]] && (( OUTPUT_SIZE > 6144 )); then
    # Need actual content for structured extraction
    if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
        OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
        OUTPUT_SIZE=${#OUTPUT}
    fi
    if (( OUTPUT_SIZE > 6144 )); then
        STRUCTURED=$(printf '%s' "$OUTPUT" | awk '
            /^[-*] /           { print; next }   # bullet points
            /^[0-9]+[.)]/      { print; next }   # numbered items
            /^#{1,4} /         { print; next }   # markdown headers
            /^[|]/             { print; next }   # table rows
            /^[[:space:]]*[-*] / { print; next } # indented bullets
            /^[a-zA-Z_.\/ ]*\.[a-z]{1,4}:[0-9]/ { print; next }  # standalone file:line refs
        ' | head -120)
        STRUCT_SIZE=${#STRUCTURED}
        if (( STRUCT_SIZE > 200 && STRUCT_SIZE < OUTPUT_SIZE )); then
            _EMIT_ORIG_TEXT="$OUTPUT" _EMIT_FINAL_TEXT="$STRUCTURED" \
            _warden_emit_event "truncated" "$OUTPUT_SIZE" "$STRUCT_SIZE" "task_structured"
            _warden_fire_token_count "$OUTPUT" "$STRUCTURED" "$(( (OUTPUT_SIZE - STRUCT_SIZE) * 10 / 35 ))" "task_structured"
            jq -n --arg text "${STRUCTURED}

[Agent output compressed: $((OUTPUT_SIZE/1024))KB -> $((STRUCT_SIZE/1024))KB structured lines]" \
                '{"modifyOutput":$text}'
            exit 0
        fi
    fi
    # Fall through to generic truncation if structured extraction yielded too little
fi

# Fast path: small outputs (subagent Reads use tighter 10KB threshold)
# Clamp to suppress threshold so oversized outputs can't bypass suppression
TRUNCATION_THRESHOLD=$WARDEN_TRUNCATE_BYTES
if [[ "$IS_SUBAGENT" == true && "$TOOL_NAME" == "Read" ]]; then
    TRUNCATION_THRESHOLD=$WARDEN_SUBAGENT_READ_BYTES
fi
(( TRUNCATION_THRESHOLD > WARDEN_SUPPRESS_BYTES )) && TRUNCATION_THRESHOLD=$WARDEN_SUPPRESS_BYTES
(( OUTPUT_SIZE <= TRUNCATION_THRESHOLD )) && { _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _exit_clean_or_suppress; }

# Need actual output content for truncation - extract only when needed
# Skip re-extraction if reminder strip already populated OUTPUT
if [[ "$REMINDER_PRE_STRIPPED" != true ]]; then
    OUTPUT=$(printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null)
    OUTPUT_SIZE=${#OUTPUT}

    # Re-check after actual extraction (jq length vs bash length may differ)
    (( OUTPUT_SIZE <= TRUNCATION_THRESHOLD )) && { _warden_emit_event "allowed" "$OUTPUT_SIZE" "$OUTPUT_SIZE"; _exit_clean_or_suppress; }
fi

# Binary check: detect null bytes portably (no grep -P which is Linux-only)
# od + grep is POSIX-compliant and works on macOS/Linux/BSD
if printf '%s' "$WARDEN_INPUT" | jq -r '.tool_response.content[0].text // ""' 2>/dev/null | od -An -tx1 | grep -q ' 00'; then
    _warden_emit_event "truncated" "$OUTPUT_SIZE" 50 "binary_output"
    _warden_fire_token_count "$OUTPUT" "" "$(( (OUTPUT_SIZE - 50) * 10 / 35 ))" "binary_output"
    jq -n --arg text "[Binary output: $((OUTPUT_SIZE/1024))KB. Use 'file' or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# >500KB: suppress entirely
if (( OUTPUT_SIZE > WARDEN_SUPPRESS_BYTES )); then
    _warden_emit_event "truncated" "$OUTPUT_SIZE" 60 "output_suppressed"
    _warden_fire_token_count "$OUTPUT" "" "$(( (OUTPUT_SIZE - 60) * 10 / 35 ))" "output_suppressed"
    jq -n --arg text "[Output too large: $((OUTPUT_SIZE/1048576))MB. Use | head or redirect.]" '{"modifyOutput":$text}'
    exit 0
fi

# Truncate large outputs.
# RE-tool outputs (nm, strings, otool): head-only — tails are alphabetically last
# symbols or stale log lines, never useful. Other outputs: 8KB head + 2KB tail.
# SSH noise cleaning is independent of truncation strategy — generic SSH output
# (e.g. remote logs) keeps head+tail so the newest lines aren't lost.
HEAD="${OUTPUT:0:8000}"
if [[ "$COMMAND" == *"nm "* || "$COMMAND" == *" nm" || \
      "$COMMAND" == *"strings "* || "$COMMAND" == *"otool"* || \
      "$COMMAND" == *"jtool"* || "$COMMAND" == *"class-dump"* ]]; then
    FINAL="${HEAD}"
    FINAL_SIZE=${#FINAL}
    TAIL_NOTE="head-only"
else
    TAIL="${OUTPUT: -2000}"
    FINAL="${HEAD}
... [$((OUTPUT_SIZE/1024))KB truncated to 10KB] ...
${TAIL}"
    FINAL_SIZE=${#FINAL}
    TAIL_NOTE="output_truncated"
fi
_EMIT_ORIG_TEXT="$OUTPUT" _EMIT_FINAL_TEXT="$FINAL" \
_warden_emit_event "truncated" "$OUTPUT_SIZE" "$FINAL_SIZE" "$TAIL_NOTE"
_warden_fire_token_count "$OUTPUT" "$FINAL" "$(( (OUTPUT_SIZE - FINAL_SIZE) * 10 / 35 ))" "$TAIL_NOTE"
jq -n --arg text "$FINAL" '{"modifyOutput":$text}'
