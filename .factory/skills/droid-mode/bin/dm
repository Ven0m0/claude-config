#!/usr/bin/env node
import fs from "node:fs";

import { parseArgs, printTable, listAllDaemons } from "../lib/util.mjs";
import { loadMcpConfigs, resolveServer, summarizeServerForDisplay, listAllServers } from "../lib/config.mjs";
import { McpClient } from "../lib/mcp_client.mjs";
import { getToolsCached, compactToolSummaries } from "../lib/tool_index.mjs";
import { searchTools } from "../lib/search.mjs";
import { hydrateTools } from "../lib/hydrate.mjs";
import { createToolApi, executeWorkflow, writeRunArtifact } from "../lib/run.mjs";
import { isDaemonRunning, callViaDaemon, getDaemonStatus, shutdownDaemon, startDaemon, ensureDaemonRunning, warmServers, getCurrentDaemonPaths } from "../lib/daemon_client.mjs";
import { setServerAutoWarm, getServerState } from "../lib/state.mjs";

function usage() {
  return `
Droid Mode (dm) - Progressive Code-Mode MCP workflows for Factory Droid

Usage:
  dm servers [--json]
  dm doctor  --server <name> [--no-connect] [--json]
  dm index   --server <name> [--refresh] [--json]
  dm search  "<query>" --server <name> [--limit 8] [--refresh] [--json]
  dm hydrate <tool1> <tool2> ... --server <name> [--out <dir>] [--refresh] [--json]
  dm run     --workflow <file.js> --tools <a,b,...> --server <name> [--retries 3] [--timeout-ms 300000]
  dm call    <tool> --server <name> [--args '{...}'] [--args-file path.json] [--json] [--no-daemon]

Daemon (persistent connections for faster calls):
  dm daemon start               → Start background daemon for current project
  dm daemon stop                → Stop current project's daemon
  dm daemon status [--json]     → Show current project's daemon status
  dm daemon status --all        → List all running daemons
  dm daemon list                → Alias for status --all
  dm daemon warm [<server>]     → Pre-warm server(s)

Configuration:
  dm config <server> autoWarm true|false  → Enable/disable auto-warm for server

Progressive Disclosure Flow:
  1. dm servers              → Discover available MCP servers
  2. dm index --server X     → List tools on server X
  3. dm search "..." --server X → Find relevant tools
  4. dm hydrate tool1 --server X → Get full schemas
  5. dm run --server X ...   → Execute workflow

Manual connection overrides (optional):
  --http-url <url> [--headers-json '{"Authorization":"Bearer ..."}']
  --stdio-command <cmd> [--stdio-args "a,b,c"] [--env-json '{"KEY":"VALUE"}']

Notes:
- Servers with 'disabled: true' in mcp.json are fully available here.
  That flag only prevents Droid from loading tools into context.
- Tool inventory is cached under .factory/droid-mode/cache/<server>/tools.json
- When daemon is running, 'dm call' uses it automatically (~5x faster).
`.trim();
}

function fail(msg, code = 1) {
  process.stderr.write(String(msg).trim() + "\n");
  process.exit(code);
}

/**
 * Resolve server entry from explicit flags OR from mcp.json.
 * @param {Record<string, any>} flags
 */
function resolveServerFromFlags(flags) {
  // HTTP override
  if (flags["http-url"]) {
    const url = String(flags["http-url"]);
    let headers = {};
    if (flags["headers-json"]) {
      try {
        headers = JSON.parse(String(flags["headers-json"]));
      } catch (err) {
        throw new Error(`Invalid --headers-json: ${err.message || err}`);
      }
    }
    return { serverName: flags.server ? String(flags.server) : "http", entry: { type: "http", url, headers } };
  }

  // stdio override
  if (flags["stdio-command"]) {
    const command = String(flags["stdio-command"]);
    const args = flags["stdio-args"]
      ? String(flags["stdio-args"])
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean)
      : [];
    let env = {};
    if (flags["env-json"]) {
      try {
        env = JSON.parse(String(flags["env-json"]));
      } catch (err) {
        throw new Error(`Invalid --env-json: ${err.message || err}`);
      }
    }
    return { serverName: flags.server ? String(flags.server) : "stdio", entry: { type: "stdio", command, args, env } };
  }

  // Default: mcp.json
  const resolved = resolveServer({ server: flags.server });
  return { serverName: resolved.serverName, entry: resolved.entry };
}

async function withClient(serverName, entry, fn) {
  const client = new McpClient({ serverName, entry });
  try {
    return await fn(client);
  } finally {
    try {
      await client.close();
    } catch {}
  }
}

async function cmdServers(args) {
  const servers = listAllServers();

  if (args.flags.json) {
    process.stdout.write(JSON.stringify({ servers }, null, 2) + "\n");
    return;
  }

  if (!servers.length) {
    process.stdout.write("No MCP servers configured.\n");
    process.stdout.write("Add servers via `droid mcp add` or create ~/.factory/mcp.json\n");
    return;
  }

  printTable(
    servers.map((s) => ({
      name: s.name,
      type: s.type,
      "droid-context": s.disabledInDroid ? "disabled (good!)" : "enabled",
    })),
    ["name", "type", "droid-context"]
  );

  process.stdout.write(`\n${servers.length} MCP server(s) available to droid-mode.\n`);
  process.stdout.write(`Tip: "disabled" servers won't bloat Droid's context - that's the point!\n`);
}

async function cmdDoctor(args) {
  const { projectPath, userPath } = loadMcpConfigs();

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const summary = summarizeServerForDisplay(entry);

  if (args.flags.json) {
    const out = {
      projectMcpPath: projectPath,
      userMcpPath: userPath,
      serverName,
      server: summary,
    };
    if (args.flags["no-connect"]) {
      process.stdout.write(JSON.stringify(out, null, 2) + "\n");
      return;
    }
    const res = await withClient(serverName, entry, async (client) => {
      await client.init();
      const tools = await client.listTools();
      return {
        toolCount: Array.isArray(tools?.tools) ? tools.tools.length : 0,
        protocolVersion: client.negotiatedProtocolVersion,
        serverInfo: client.serverInfo,
      };
    });
    out.connection = res;
    process.stdout.write(JSON.stringify(out, null, 2) + "\n");
    return;
  }

  process.stdout.write(`Project mcp.json: ${projectPath || "(not found)"}\n`);
  process.stdout.write(`User mcp.json:    ${userPath}\n`);
  process.stdout.write(`Server: ${serverName}\n`);
  process.stdout.write(`Config: ${JSON.stringify(summary, null, 2)}\n`);

  if (!args.flags["no-connect"]) {
    process.stdout.write(`\nConnecting...\n`);
    const res = await withClient(serverName, entry, async (client) => {
      await client.init();
      const list = await client.listTools();
      return {
        toolCount: Array.isArray(list?.tools) ? list.tools.length : 0,
        protocolVersion: client.negotiatedProtocolVersion,
        serverInfo: client.serverInfo,
      };
    });
    process.stdout.write(`Connected. Tools: ${res.toolCount}\n`);
    process.stdout.write(`Protocol: ${res.protocolVersion}\n`);
    if (res.serverInfo) process.stdout.write(`ServerInfo: ${JSON.stringify(res.serverInfo)}\n`);
  }
}

async function cmdIndex(args) {
  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools, cacheFile, cached } = await getToolsCached({ serverName, client, refresh });
    const summaries = compactToolSummaries(tools);
    return { summaries, cacheFile, cached };
  });

  if (args.flags.json) {
    process.stdout.write(
      JSON.stringify({ serverName, cacheFile: res.cacheFile, cached: res.cached, tools: res.summaries }, null, 2) + "\n"
    );
    return;
  }

  printTable(
    res.summaries.map((t) => ({ 
      name: t.name, 
      requires: t.requires || "-",
      description: t.description.slice(0, 80) 
    })),
    ["name", "requires", "description"]
  );
  process.stdout.write(`Cache: ${res.cacheFile} (${res.cached ? "hit" : "refreshed"})\n`);
}

async function cmdSearch(args) {
  const query = args._[1];
  if (!query) fail(`Missing query.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const limit = args.flags.limit ? Number(args.flags.limit) : 8;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools } = await getToolsCached({ serverName, client, refresh });
    const matches = searchTools(tools, query, { limit });
    return { matches };
  });

  if (args.flags.json) {
    process.stdout.write(JSON.stringify({ serverName, query, matches: res.matches }, null, 2) + "\n");
    return;
  }

  printTable(
    res.matches.map((m) => ({ name: m.name, score: m.score.toFixed(2), description: m.description.slice(0, 140) })),
    ["name", "score", "description"]
  );
}

async function cmdHydrate(args) {
  const toolNames = args._.slice(1);
  if (!toolNames.length) fail(`Missing tool names.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const outDir = args.flags.out ? String(args.flags.out) : undefined;

  const res = await withClient(serverName, entry, async (client) => {
    const { tools } = await getToolsCached({ serverName, client, refresh });
    // const { outDir, selectedCount, toolmap } = hydrateTools({ serverName, tools, toolNames, outDir });
    // return { outDir, selectedCount, toolmap };
    return hydrateTools({ serverName, tools, toolNames, outDir });

  });

  if (args.flags.json) {
    process.stdout.write(
      JSON.stringify({ serverName, outDir: res.outDir, selectedCount: res.selectedCount, toolmap: res.toolmap }, null, 2) +
        "\n"
    );
    return;
  }

  process.stdout.write(`Hydrated ${res.selectedCount} tools to:\n  ${res.outDir}\n`);
}

async function cmdRun(args) {
  const workflowPath = args.flags.workflow || args.flags.w;
  const toolsCsv = args.flags.tools || args.flags.t;
  if (!workflowPath || !toolsCsv) fail(`Missing --workflow and/or --tools.\n\n${usage()}`);

  const toolNames = String(toolsCsv)
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  if (!fs.existsSync(workflowPath)) fail(`Workflow file not found: ${workflowPath}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  const refresh = !!args.flags.refresh;
  const timeoutMs = args.flags["timeout-ms"] ? Number(args.flags["timeout-ms"]) : undefined;
  const allowUnsafe = !!args.flags["allow-unsafe"];
  const maxRetries = args.flags.retries ? Number(args.flags.retries) : 3;

  const trace = [];

  const output = await withClient(serverName, entry, async (client) => {
    // Ensure tools exist (via cache)
    const { tools } = await getToolsCached({ serverName, client, refresh });
    const available = new Set((tools || []).map((t) => t?.name));
    const missing = toolNames.filter((n) => !available.has(n));
    if (missing.length) {
      throw new Error(`Unknown tool(s) for server "${serverName}": ${missing.join(", ")}`);
    }

    const toolApi = createToolApi({ client, toolNames, trace, maxRetries });
    const { result, logs } = await executeWorkflow({
      workflowPath,
      toolApi,
      timeoutMs,
      allowUnsafe,
    });
    return { result, logs, toolmap: toolApi.toolmap };
  }).catch((err) => {
    // Persist a failure run artifact too.
    const failOut = {
      ok: false,
      error: String(err?.message || err),
    };
    const artifact = writeRunArtifact({
      serverName,
      workflowPath,
      tools: toolNames,
      output: failOut,
      trace,
    });
    if (args.flags.json) {
      process.stdout.write(JSON.stringify({ ...failOut, artifact }, null, 2) + "\n");
      return;
    }
    fail(`${failOut.error}\nArtifact: ${artifact.file}`);
  });

  const okOut = { ok: true, result: output.result, logs: output.logs, toolmap: output.toolmap };
  const artifact = writeRunArtifact({
    serverName,
    workflowPath,
    tools: toolNames,
    output: okOut,
    trace,
  });

  process.stdout.write(JSON.stringify({ ...okOut, artifact }, null, 2) + "\n");
}

async function cmdCall(args) {
  const tool = args._[1];
  if (!tool) fail(`Missing tool name.\n\n${usage()}`);

  let serverName, entry;
  try {
    ({ serverName, entry } = resolveServerFromFlags(args.flags));
  } catch (err) {
    fail(err.message || err);
  }

  let argObj = {};
  if (args.flags["args"]) {
    try {
      argObj = JSON.parse(String(args.flags["args"]));
    } catch (err) {
      fail(`Invalid --args JSON: ${err.message || err}`);
    }
  } else if (args.flags["args-file"]) {
    const p = String(args.flags["args-file"]);
    try {
      argObj = JSON.parse(fs.readFileSync(p, "utf-8"));
    } catch (err) {
      fail(`Invalid --args-file: ${err.message || err}`);
    }
  }

  // Try daemon first (unless --no-daemon flag is set)
  // Auto-start daemon if not running
  if (!args.flags["no-daemon"]) {
    const daemonReady = await ensureDaemonRunning();
    if (daemonReady) {
      const res = await callViaDaemon({ server: serverName, tool, args: argObj });
      if (!res.ok) {
        fail(`Daemon call failed: ${res.error}`);
      }
      if (args.flags.json) {
        process.stdout.write(JSON.stringify(res, null, 2) + "\n");
        return;
      }
      process.stdout.write(JSON.stringify(res.result, null, 2) + "\n");
      return;
    }
  }

  // Direct call (no daemon)
  const out = await withClient(serverName, entry, async (client) => {
    const res = await client.callTool({ name: tool, arguments: argObj, timeoutMs: 60_000 });
    return res;
  });

  if (args.flags.json) {
    process.stdout.write(JSON.stringify(out, null, 2) + "\n");
    return;
  }
  process.stdout.write(JSON.stringify(out.structured ?? out.text ?? out.raw, null, 2) + "\n");
}

async function cmdDaemon(args) {
  const subcmd = args._[1];
  const { socket, projectRoot } = getCurrentDaemonPaths();

  if (subcmd === "start") {
    const running = await isDaemonRunning();
    if (running) {
      process.stdout.write("Daemon is already running.\n");
      if (projectRoot) {
        process.stdout.write(`Project: ${projectRoot}\n`);
      }
      return;
    }
    try {
      const result = await startDaemon();
      process.stdout.write(`Daemon started (PID: ${result.pid})\n`);
      process.stdout.write(`Socket: ${result.socketPath}\n`);
      if (result.projectRoot) {
        process.stdout.write(`Project: ${result.projectRoot}\n`);
      } else {
        process.stdout.write(`Project: (global)\n`);
      }
    } catch (err) {
      fail(`Failed to start daemon: ${err.message}`);
    }
    return;
  }

  if (subcmd === "stop") {
    const running = await isDaemonRunning();
    if (!running) {
      process.stdout.write("Daemon is not running.\n");
      return;
    }
    await shutdownDaemon();
    process.stdout.write("Daemon stopped.\n");
    if (projectRoot) {
      process.stdout.write(`Project: ${projectRoot}\n`);
    }
    return;
  }

  if (subcmd === "status" || subcmd === "list") {
    // --all flag shows all daemons across all projects
    if (args.flags.all || subcmd === "list") {
      const allDaemons = listAllDaemons();
      
      if (args.flags.json) {
        process.stdout.write(JSON.stringify({ daemons: allDaemons }, null, 2) + "\n");
        return;
      }
      
      if (!allDaemons.length) {
        process.stdout.write("No daemons found.\n");
        return;
      }
      
      printTable(
        allDaemons.map((d) => ({
          project: d.projectPath || "(global)",
          pid: d.pid,
          status: d.alive ? "running" : (d.stale ? "stale" : "unknown"),
          started: d.startedAt?.split("T")[0] || "-",
        })),
        ["project", "pid", "status", "started"]
      );
      process.stdout.write(`\n${allDaemons.length} daemon(s) found.\n`);
      return;
    }
    
    // Default: show current project's daemon
    const running = await isDaemonRunning();
    if (!running) {
      if (args.flags.json) {
        process.stdout.write(JSON.stringify({ running: false, socket, projectRoot }, null, 2) + "\n");
      } else {
        process.stdout.write("Daemon is not running.\n");
        process.stdout.write(`Socket: ${socket}\n`);
        if (projectRoot) {
          process.stdout.write(`Project: ${projectRoot}\n`);
        } else {
          process.stdout.write(`Project: (global)\n`);
        }
      }
      return;
    }

    const status = await getDaemonStatus();
    if (args.flags.json) {
      process.stdout.write(JSON.stringify({ running: true, socket, projectRoot, ...status }, null, 2) + "\n");
      return;
    }

    const uptimeMin = Math.floor((status.uptime || 0) / 60000);
    process.stdout.write(`Daemon running (uptime: ${uptimeMin}m)\n`);
    process.stdout.write(`Socket: ${socket}\n`);
    if (projectRoot) {
      process.stdout.write(`Project: ${projectRoot}\n`);
    } else {
      process.stdout.write(`Project: (global)\n`);
    }
    process.stdout.write("\n");

    if (status.connections?.length) {
      printTable(
        status.connections.map((c) => ({
          server: c.name,
          type: c.type,
          state: c.state,
          uptime: c.uptime || "-",
          calls: c.callCount,
        })),
        ["server", "type", "state", "uptime", "calls"]
      );
    } else {
      process.stdout.write("No server connections.\n");
    }
    return;
  }

  if (subcmd === "warm") {
    const running = await isDaemonRunning();
    if (!running) {
      // Auto-start daemon for warm command
      try {
        await startDaemon();
        process.stdout.write("Daemon started.\n");
      } catch (err) {
        fail(`Failed to start daemon: ${err.message}`);
      }
    }

    const serverName = args._[2]; // Optional: specific server
    const result = await warmServers(serverName);

    if (args.flags.json) {
      process.stdout.write(JSON.stringify(result, null, 2) + "\n");
      return;
    }

    if (serverName) {
      process.stdout.write(result.warmed ? `Warmed: ${serverName}\n` : `Already warm: ${serverName}\n`);
    } else {
      const { warmed = [], failed = [] } = result;
      if (warmed.length) {
        process.stdout.write(`Warmed ${warmed.length} server(s): ${warmed.join(", ")}\n`);
      }
      if (failed.length) {
        process.stdout.write(`Failed: ${failed.join(", ")}\n`);
      }
      if (!warmed.length && !failed.length) {
        process.stdout.write("All servers already warm or none configured for auto-warm.\n");
      }
    }
    return;
  }

  fail(`Unknown daemon subcommand: ${subcmd}\nUsage: dm daemon start|stop|status|warm`);
}

async function cmdConfig(args) {
  const serverName = args._[1];
  const key = args._[2];
  const value = args._[3];

  if (!serverName || !key) {
    fail("Usage: dm config <server> <key> <value>\n\nSupported keys:\n  autoWarm true|false  - Enable/disable auto-warm for server");
  }

  if (key === "autoWarm") {
    if (value !== "true" && value !== "false") {
      fail("autoWarm must be 'true' or 'false'");
    }
    setServerAutoWarm(serverName, value === "true");
    process.stdout.write(`Set ${serverName}.autoWarm = ${value}\n`);
    return;
  }

  fail(`Unknown config key: ${key}\nSupported: autoWarm`);
}

async function main() {
  const args = parseArgs(process.argv.slice(2));
  const cmd = args._[0];

  if (!cmd || cmd === "help" || cmd === "--help" || cmd === "-h") {
    process.stdout.write(usage() + "\n");
    return;
  }

  try {
    if (cmd === "servers") return await cmdServers(args);
    if (cmd === "doctor") return await cmdDoctor(args);
    if (cmd === "index") return await cmdIndex(args);
    if (cmd === "search") return await cmdSearch(args);
    if (cmd === "hydrate") return await cmdHydrate(args);
    if (cmd === "run") return await cmdRun(args);
    if (cmd === "call") return await cmdCall(args);
    if (cmd === "daemon") return await cmdDaemon(args);
    if (cmd === "config") return await cmdConfig(args);
    fail(`Unknown command: ${cmd}\n\n${usage()}`);
  } catch (err) {
    fail(err.message || err);
  }
}

main();
